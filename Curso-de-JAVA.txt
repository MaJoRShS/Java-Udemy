Trocar a versão do JAVA no LINUX

Site com as info
https://tecadmin.net/install-java-on-fedora/

comando: sudo alternatives --config java

Ubuntu
sudo update-alternatives --config java

 

Curso de JAVA completo Udemy


Curso ministrado na udemy pelo professor nelio alves.


Seção 1: Introdução

1. Introdução: visão geral do curso

Está apresentando o curso e as principais qualidades que ele julga necessárias para ser um bom dev de JAVA, ainda deixou um arquivo que vai ser utilizado no curso.


Seção 2: Conceitos de programação

2. Visão geral do capítulo

3. Material de apoio do capítulo

Baixei o material de apoio

4. Algoritmo, Automação, Programa de Computador

Algoritmo = Sequencia bem definida de passos a serem seguidas
Automação = processo que pode ser automatizado via uma maquina
Programa = é um Algoritmo executado pelo Computador


5. O que é preciso para se fazer um programa de computador

IDE = uma interface de Desenvolvimento
Compilador = transforma o código java em programa de computador


6. Linguagem de programação, léxica, sintática

léxica = a forma de escrever

sintática = é um erro gramatical

programação = é a junção de todas elas mais em uma linguagem de programação.


7. IDE - Ambiente Integrado de Desenvolvimento

Aqui ele está mostrando algumas IDE's e para que serve.


Seção 3: Introdução à linguagem Java

8. Visão geral do capítulo

9. Material de apoio do capítulo


10. Entendendo as versões do Java

LTS - long time support

ou seja longo suporte pela oracle.


11. Histórico e edições de Java

JAVA é uma linguagem de programação mais também é uma plataforma de Desenvolvimento e execução, ou seja tem que instalar os JDKS e todo o ambiente de desenvolvimento.

O java surgiu para resolver o problema de alocação de memoria e o suporte a vários dispositivos com o mesmo código e a mesma aplicação.

JAVA ME  - micro edition = usada para IOT por ser mais leve 

JAVA SE  - Standard Edition = usado para tudo , tem o core do java

JAVA EE  - Enterprise Edition = Aplicações corporativas



12. JDK / JVM - Máquina Virtual do Java

JVM - JAVA VIRTUAL MACHINE

essa aqui é a maquina virtual do java que interpreta e compila o código.

aqui ele mostra que o java é uma linguagem que está no meio termo entre as compiladas e as interpretadas, segundo ele o java interpreta o código e já corrige erros na syntax e na semântica e ai gera o byte code, que ja é otimizado, ai sim ele compila o código já performado , na JVM de cada SO e ai roda lindo.


13. Estrutura de uma aplicação Java

Todo código java tem que estar em classes, e essas classes agrupadas são os pacotes(packages), e vários pacotes agrupados foram um modulo, que por sua vez com vários outros módulos agrupados formam um sistema.
Run-time = é a compilação ou build de um determinado grupo de pacotes para serem instalados em algum dispositivo.


14. Instalando Java

Essas aulas eram no Windows, que é nível macaco e eu já adotei como ambiente de desenvolvimento o LINUX

15. Instalando o Eclipse

Igual a aula anterior


16. Primeiro programa em Java no Eclipse

Aqui ele fala do "workspace" que é o diretório que seus projetos serão salvos, e todas as vezes que o eclipse for inicializado ele vai te perguntar se você quer mudar esse diretório.

outra coisa é a perspetiva, no nosso caso estamos utilizando a JAVA, é só ir em "window > perspective > open perspective > java" caso não tenha vai em "other..." e escolhe o java.

para voltar a perspetiva igual ao padrão vai no mesmo caminho e clica em "reset perspective"

Mostra o console "Window > show view > console"


***
Aqui tem um bizu 

Usando o comando 'sudo alternatives --config java' eu consigo escolher no meu fedora entre quais opções do java eu quero usar, das que estão instaladas no PC.


***

criou o primeiro programa em java, mostrou que sou obrigado a criar uma classe para executar qualquer coisa no java e ainda deixou a classe como sendo executável.

Seção 4: Estrutura sequencial


17. Visão geral do capítulo

18. Material de apoio do capítulo


19. Expressões aritméticas
Aqui ele mostrou os 5 tipos de operadores aritméticos, e mostrou que mesmo em java temos precedência de execução, como na matemática normal, isso significa que tudo que estiver entre parênteses"()" vai ser executado primeiro.
obs. em programação não existe chaves nem colchetes para expressões aritméticas só os parênteses.


20. Variáveis e tipos básicos em Java

Demonstrou como devem ser declarados os tipos de variável no java, explicou como são armazenadas na memoria e que toda variável tem um nome ou identificador, e que possui um tipo (existem vários ele mostrou apenas os 8 primitivos).

Numéricos Inteiros
byte   - 8 bites
short  - 16 bites
int    - 32 bites
long   - 64 bites

Numéricos com Ponto flutuante
float   - 32 bites
double  - 64 bites

Carácter Unicode
char - 16 bites

Valor Verdade
boolean - 1 bite

String
Armazena uma cadeia de Caracteres.

Padrão de nomenclatura de variável
Nunca inicia com números , sempre com letras ou _
Não pode ter espaçoes em branco entre o nome da variável
Não se usa acentuação nem caracater especial
E usa-se o padrão Camel Case, ou seja a primeira letra de cada palavra tem que ser maiuscula.


21. As três operações básicas de programação

Entrada de dados ou escrita = é quando o usuario insere dados por meio de um teclado ou touch

processamento de dados = é o processo que o computador faz com os dados que foram enviados para ele e depois devovlve alguma informação do que foi processado

Saida de dados ou escrita = é o processo de devolução do computador após o processamento para o usuario por meio de um periferico de saida como o monitor.


22. Saída de dados em Java

Para retornar dados para os usuarios temos algumas formas, 

Essa forma não tem uma quebra de linha no final, se eu colocar mais alguma coisa para aparecer na tela ele simplesmente vai escrever tudo junto.
System.out.print("Olá Mundo");


já aqui tem a quebra de linha no final, ou seja fica esse conteúdo e o proximo já estaria na proxima linha.
System.out.println("Olá Mundo");


para imprimir valores de variaveis temos algumas formas
int x = 32;
double y = 10.35784
System.out.println(x);
System.out.println(y);


mais para você poder formatar os valor do double você pode usar o comando 


int x = 32;
double y = 10.35784
System.out.printf("%.2f%n",y);

Aqui o printf é para formatar o numero, e o "%.2f%" é o indicador de que eu só quero duas casas decimais, e o %n serve para quebra de linha na apresentação dos dados, já o proxima valor após a virgula é a variável que eu quero apresentar formatada.

Aqui ainda tem um esquema na formatação que é para apresentação com "." ou "," por padrão o comando "System.out.printf();" ele pega as configurações do seu computador para usar como padrão por isso aqui ele sempre apresenta com "," e para apresentarmos com "." temos que utilizar uma classe padrão do java que é a "Locale"

import java.util.Locale;
Importa ele no começo do programa.

Locale.setDefault(Locale.US);
Usa ela no começo do programa também porque essas configurações só teram efeito depois da declaração do locale.


Para concatenar mais de um dado de retorno é simples é so mandar o "+" entre os textos e as variaveis assim:
System.out.println("Texto qualquer " + y + " Final do texto qualquer");

já nesse exemplo estou concatenando texto formatado com 2 casas decimais, a unica diferença é que se eu tivesse mais alguma coisa para printar na tela e precisaria de mais alguns "%.N" e ai as variaveis tem que ser colocadas na ordem em que eu defini os %.
System.out.printf("Resultado = %.2f  Metros%n", y);

Aqui temos outro exemplo porém concatenando vários tipos de dados no mesmo retorno, ou seja uma string, um inteiro e um double, e para fazer isso temos algumas marcações no JAVA como por exemplo:

%s = String

%d = Inteiro(int)

%f = Ponto flutuante (double)

%n = Quebra de linha

Obs. Tem que declarar as variaveis no começo do programa.
System.out.println("%s tem %d anos e ganha R$ : %.2f reais %n", nome, idade, renda);


Deixou um exercicio de fixação. 

Obs. Movi todo o repositório do git para dentro do meu workspace do eclipse para que assim eu consiga subir os códigos da aula e dos exercícios de fixação.


23. Processamento de dados em Java, Casting

Aqui ele fala que o processamento de dados em java é igual qualquer outra lingaguem onde você cria uma variável e ai depois você atribui uma expressão a ela, ou um valor direto.

e que o casting é quando você faz a conversão explisita de tipos de dados.

uma boa pratica de programação é sempre declarar os valores igual ao seu tipo, exemplo valores double sempre com o ".0" e se for float sempre mandar com "f" depois do numero,  "5f".


O casting seria no caso de uma perda de dados ou conversão de tipos de dados entre algum processamento, por exemplo estou somando dois inteiros e quero forçar que o retorno seja um double eu coloco "(double)" antes das variaveis na declaração que ai o compilador intende que deve converter aquele valor para double, e até mesmo no caso de perda de valor se você usar o casting ele aceita, no exemplo de conversão de double para inteiro.



24. Entrada de dados em Java - Parte 1

Aqui ele mostra que os dados que são digitados via teclado tem uma classe que já pega os dados, a Scanner, é só dar aquele importe que tudo funciona, para pegar os dados cada tipo tem um método especifico.

declaração do Scanner.

        Scanner sc = new Scanner(System.in);

    String x;
    x = sc.next();

    Inteiro
    int x;
    x = sc.nextInt();

    Double
    double x;
    x = sc.nextDouble();

Aqui tem uma parada, o separador de decimal sempre vai respeitar sua localidade, ou seja BR o separador e "," USA o separador é ".", então se você quiser mudar tem que madar o Locale.

    Locale.setDefault(Locale.US);

    Caracter
    char x;
    x = sc.next().charAt(0);
    Aqui o charAt() vai pegar o caracater que você informar a posição, pode ser o 1 como no exemplo acima mais pode ser qualquer outro.



    Ler varias palavras da mesma linha com tipos diferentes
    string x;
    int y;
    double z;
    x = sc.next();
    y = sc.nextInt();
    z = sc.nextDouble();




25. Entrada de dados em Java - Parte 2

    Scanner sc = new Scanner(System.in);
    String s1, s2, s3;
    s1 = sc.nextLine();
    s2 = sc.nextLine();
    s3 = sc.nextLine();
    System.out.println("DADOS DIGITADOS:");
    System.out.println(s1);
    System.out.println(s2);
    System.out.println(s3);
    sc.close();


Exemplo acima ele vai pegar todo o conteudo até a quebra de linha e por isso se usa o "sc.nextLine();"


Quando você usa um comando de leitura diferente do nextLine() e dá alguma quebra de linha, essa quebra de linha fica "pendente" na entrada padrão.
Se você então fizer um nextLine(), aquela quebra de linha pendente será absorvida pelo nextLine().

Solução:
Faça um nextLine() extra antes de fazer o nextLine() de seu interesse.


    int x;
    String s1, s2, s3;
    x = sc.nextInt();
    s1 = sc.nextLine();
    s2 = sc.nextLine();
    s3 = sc.nextLine();
    System.out.println("DADOS DIGITADOS:");
    System.out.println(x);
    sc.nextLine();
    System.out.println(s1);
    System.out.println(s2);
    System.out.println(s3);


O eclipse deu uma call interessante, ele aqui transformou o meu objeto "sc" do Scanner em uma variável statica ou seja eu não vou altera-la nem ninguém , e ai eu declaro ele na inicialização do programa e ainda já era, fica tudo certo.


26. Funções matemáticas em Java

Aqui ele está mostrando que existe uma classe em java que é responsável por cálculos matemáticos, e que praticamente já está tudo la pronto para uso.

A = Math.sqrt(x);   Variável A recebe a raiz quadrada de x
A = Math.pow(x, y); Variável A recebe o resultado de x elevado a y
A = Math.abs(x);    Variável A recebe o valor absoluto de x

• sqrt – raiz quadrada
• pow – potenciação
• abs – valor absoluto

e que é possível executar funções complexas com java apenas concatenando esses métodos.



27. AVISO: exercícios para iniciantes PARTE 1

Aqui ele está explicando que tem exercícios propostos em uma aula do youtube e tals e que os questionarios respondidos estão em um repo no github, ai é meio que obrigatório para quem é iniciante na parada e opcional para quem já desenrola na logica de programação.

vou fazer FODA-SE.

28. Exercícios para Iniciantes - PARTE 1

Baixie o conteudo, vou ver o video e mandar os exercícios.


Video do youtube tem um exercicio. [ done ]

Execicos do PDF

acho que vou mandar uma classe por aula, mesmo que fique bastante conteúdo é melhor mais organizado e bem mais facil a consulta depois.


Seção 5: Estrutura condicional

29. Visão geral do capítulo
Deu uma Introdução bem simplista.

30. Material de apoio do capítulo
Download do material do modulo.

31. Expressões comparativas

Aqui ele está mostrando os operadores comparativos igual o da maioria das linguagens
Operador Significado
>        maior
<        menor
>=        maior ou igual
<=        menor ou igual
==        igual
!=        diferente



32. Expressões lógicas

Operador Significado
&&       E
||       OU
!        NÃO


Aqui é o mesmo esquema da logica matematica, e que também tem em toda linguagem de programação, ele nos exemplos não está usando nada de programação só tabela verdade.

na real aqui ele falo o b asico da tabela verdade, é bem basico mesmo.

33. Estrutura condicional (if-else)

Estrutura condicional é uma estrutura de controle, que depende de uma condição, o que significa que se eu quiser tomar uma determinada ação eu devo verificar se aquela condição foi atendida ai sim eu executo o que foi programado.


existe três tipos de estrutura condicional a simples, composta e aninhada ou encadeadas.

Aqui tem umas dicas, se você tem apenas uma condição no seu if não precisa colocar as chaves, é opcional, mais mesmo assim é o esquema colocar para não se perder no código.

não tem condição no else, e da para mandar o else if mais ou menos igual no php , ai se usa dessa forma aqui


if ( condição 1 ) {
    comando 1
    comando 2
}
else if ( condição 2 ) {
    comando 3
    comando 4
}
else if ( condição 3 ) {
    comando 5
    comando 6
}
else {
    comando 7
    comando 8
}


34. AVISO: exercícios para iniciantes
Aviso e mais nada, mesmo assim vou fazer os exercícios e dane-se.


35. Exercícios para Iniciantes - PARTE 2
Termieni os exercícios.


36. Sintaxe opcional - operadores de atribuição cumulativa
Aqui ele mostra que fazer do jeito que ele costuma fazer da certo mais é melhor fazer utilizando os operadores de atribuição acumulativa.


a += b;     a = a + b;
a -= b;     a = a - b;
a *= b;     a = a * b;
a /= b;     a = a / b;
a %= b;     a = a % b;


37. Sintaxe opcional - switch-case

Aqui ele mostrou a syntax do switch-case, que nada mais é que uma alternativa para você não ter que ficar fazendo inúmeros if else, claro que não é só isso, ele tem inúmeras vantagens, e ainda deixa o código mais legível.

padrão igual a maioria das linguagens abre o "switch(){}" com uma expressão ou variável como parâmetro, e ai vem as condições dentro das chaves todas elas com seus "case" a syntax é essa.

switch ( expressão ) {
    case valor1:
        comando1
        comando2
        break;
    case valor2:
        comando3
        comando4
        break;
    default:
        comando5
        comando6
        break;
}

Caso exista e você quiser colocar quando você usa o "default" se nenhum dos valores do case existirem ele apresenta essa mensagem.



38. Expressão condicional ternária

Aqui ele mostra a syntax da condicional ternário que serve para simplificar código if else, e claro se você não tiver muitas condições para serem verificadas.

syntax:
( condição ) ? valor_se_verdadeiro : valor_se_falso

( 2 > 4 ) ? 50 : 80 = Aqui o resultado vai ser 80 porque o resultado da expressão é negativo, então ele vai para o 80
( 10 != 3 ) ? "Maria" : "Alex" = Aqui o resultado é maria porque o resultado da expressão é verdadeiro

Aqui é claro vai depender muito a utilização, nem todo mundo conhece a ternário, e mesmo assim é para coisas bem simples, mais ainda assim acho que como sempre o if else é o mais utilizado nem lembramos do ternário.


39. Escopo e inicialização

Aqui ele mostra os escopos dentro do programa, e mostra que no java as variaveis para terem sido iniciadas não basta apenas terem sido declaradas, elas tem que possuir algum valor, mesmo que "0". e que também variaveis que foram declaradas dentro de funções não existem no escopo fora da função a menos que você declare ela no escopo global não adianta ela não vai funcionar. 


Seção 6: Estruturas repetitivas
40. Visão geral do capítulo

falou como que vai funcionar o modulo.

41. Material de apoio do capítulo
baixei o material de apoio.

42. Como utilizar o DEBUG no Eclipse(execução passo a passo)

Mostrou utilizar o DEBUG no eclipse , é bem simples ao invés de executar com java aplication usa o "debug as " e ai sim o java aplication, ele vai mudar a perspectiva para o modo debug caso voce aperte sim para  a mensagem que aparecer.
para passa linha a linha é só usar o "F6" e ai ele vai passando linha a linha a execução do programa.


43. Estrutura repetitiva enquanto (while)

Aqui ele mostrou como funcina o while, e que ele é utilizando para repetir uma ação ou executar algo enquanto uma condição for verdadeira, e que ele é mais utilizado para quando não se sabe ao certo a quantidade de vezes que será necessario executar.

syntax
while ( condição ) {
    comando 1
    comando 2
}


44. Teste de mesa com estrutura repetitiva enquanto

ele executou um teste de mesa com while, e fez executando linha a linha para conseguirmos enteder como funciona a execução do programa e como se da composição de valores em uma estrutura como o while.

45. Exercícios de teste de mesa com while

Disse que tem exercícios no PDF como teste de mesa, eu fiz todos , é bem maneiro,porque você acaba percebendo como que ele vai ser executado e talvez consiga perver algum erro.


46. AVISO: exercícios para iniciantes PARTE 3
Aviso para fazer o exercicio quem é iniciante, ou tem dificuldade de entender.

47. Exercícios para Iniciantes - PARTE 3
exercícios feitos.



48. Estrutura repetitiva para (for)

O for serve para quando você já sabe previamente a quantidade de vezes em que você vai precisar executar uma ação, tem que praticar porque é um pouco diferente a forma de usar para pegar os valores digitados pelo usuario, eu sempre usei o for para retorno de BD.


49. Teste de mesa com estrutura repetitiva para

Acompanhei ele fazendo o teste de mesa.


50. Exercícios de testes de mesa com for

Falou que vai ter exercícios.

51. AVISO: exercícios para iniciantes PARTE 4

vou fazer do mesmo jeito, são exercícios de teste de mesa que estão no material de apoio, to acertando suave.
fiz todos, acho agora que fazer essas paradas não são perca de tempo, acredito que além de fixação serve muito para fazer sua cabeça pensar em como tudo isso funciona e como deve funcionar.


52. Exercícios para iniciantes PARTE 4

Fiz todos os exercícios.


53. Estrutura repetitiva faça-enquanto (do-while)

Aqui é bem interessante porque ele executa o bloco de instrução antes de fazer a validação, o que é util quando você sabe que precisa pelo menos uma unica vez executar todo o seu bloco.


Seção 7: Outros tópicos básicos sobre Java
54. Material de apoio do capítulo
Baixei o material

55. Restrições e convenções para nomes

Aqui nada mais é que o padrão de nomenclatura 

Camel case: lastName
    pacotes
    atributos
    métodos
    variaveis e parâmetros


Pascal Case: ProductService
    classes


56. Operadores bitwise

Aqui ele está falando que essas operações bitwise são operações bit a bit, e que se eu passar dois valores binarios por exemplo para serem comparados ele vai comparar usando a tabela verdade bit a bit dos dois números binarios que eu passei.

tem as operações logicas normais.


usa normal 
var_1 & var_2; E
var_1 | var_2; OU
var_1 & var_2; OU-exclusivo


57. Funções interessantes para String

Aqui as paradas para formatação de string ou para trabalhar com string são bem pareceidas com o PHP, mais ainda assim em algumas diferenças, mais assim como o PHP eu tenho que dar uma olhada ainda melhor nos DOCS, deve ter muito mais coisa para string.


58. Comentários em Java (básico) 

Comentário de bloco é quando eu abro com "/*" e no final do bloco independente de em qual linha eu fechei o "*/" esse é o bloco de Comentário.

o Comentário de linha é só mandar um "//" e ai ele comenta tudo naquela linha


59. Funções (sintaxe)

Explicou como funciona uma função em java,e explicou o que é uma função, vantagens e desvantagens.


Seção 8: Introdução à Programação Orientada a Objetos
60. Visão geral do capítulo

61. Material de apoio do capítulo


62. Resolvendo um problema sem orientação a objetos

Aqui ele meteu marcha e fez logo um programa que calcula a area de 2 triangulos e ainda vê qual deles tem a area maior, ele fez no procedural mesmo, e na proxima aula vai mandar no Orientado a Objetos.

E ele também está mudando a estrutura de pastas, agora ele está colocando o "String Args" no package aplication.


63. Criando uma classe com três atributos para representar melhor o triângulo

Aqui ele explica melhor o que é uma classe, e que ela tem atributos e métodos e que os atributos são as caracteristicas da classe, e que os métodos são funções que essa classe executa, e recebe o nome de método porque só faz parte da classe e não do escopo todo do programa.

falou sobreos pricipios de uma classe, mais bem preve, e mostrou que todas as vezes que você instancia uma classe na real na "STACK" o valor que fica armazenado na varivel do tipo "Object" é uma referencia de memoria que aponta(ponteiro) para a area da "HEAP" onde realmente está os valores armazenados para cada atributo daquele objeto, e que os objetos por serem assim precisam ser instanciados, e isso é feito com o comando "new" e isso que diz ao programa para armazenar aquela referencia de memoria onde ele vai armazenar os valores.



64. Criando um método para obtermos os benefícios de reaproveitamento e delegação

Aqui ele passou todo a função que calcula  area do triangulo para dentro da classe tornando assim um método, e ainda simplificou poruque ele criou o método uma vez e utilizou para dois triangulos diferentes.

muita coisa está comentada nos códigos quando for mais conceitual eu mando aqui, ou vou intercalando, o que for mais importante deixar la eu deixo e o que for conteúdo normal eu mando aqui mesmo.

Falou sobre o projeto de classe em UML, que facilita a visualização do que tem que ser construido e como deve ficar, com seus atributos e métodos , e com seus respectivos tipos de dados.
 
e frizou mais uma vez que com classes você reutiliza código, o que torna o processo mais agil e e menos caro, e que com as classes você consegue delegar responsabilidade, para cada classe ser especializada naquilo que ele faz.



65. Começando a resolver um segundo problema exemplo

Aqui ele fez uma classe de produto que tem 3 métodos e 3 atributos, nada muito complexo mais bem legalzin para ir fixano as paradas na mente.


OBS. acho que vou começar a criar um pacote por aula, ou fazer tudo que tiver que fazer commitar e apagar porque ta foda, o eclipse entra em loop na hora de builda as paradas e ainda fica dando erro porque tem mais de um método inicial.


66. Object e toString

Aqui ele apresenta o "toString();"  esse cara basicamente é nativo do Object em java que é a classe pai de todos os objetos, e aqui ele consegue sobrescrever o método nativo e alterar o comportamento dele, o que não muda a utilização do método mais sim o retorno dele.

ainda apresentou o "String.format(format, args)" que serve para formatar strings basicamente ali ele fala o formato que ele quer que saia e quala variável que vai ser formatada assim.

OBS. ainda falta mudar os valores mais está funcionando certinho até as chamadas dos métodos.

67. Finalizando o programa

Aqui finalizamos o programa colocando as informações formatadas e apenas somando a quantidade de produtos em estoque, achei que eu já tivesse colocado as informações no github mais se pans não o fiz.


68. Exercícios de fixação

Fiz todos os exercícios de fixação , eu só fiquei pistola porque o ultimo exercicio que o cara mandou fazer não tinha exemplo e o melhor ele deu peso para as notas, mais ai no exemplo dele não tem peso nenhuma nas notas, até porque o peso que ele deu valeria de porra nenhuma peso doido da peste.


A Partir daqui eu vou ter que criar um projeto por aula, ou pelo menos qundo for importante, porque o eclipse aqui do linux buga lindo quando eu tenho mais de uma classe com o método de inicialização, e quando tiver mais conteúdo da mesmo aula acho que vou comentar dentro da propria classe o exemplo ai fica mais facil de achar depois.



69. Membros estáticos - Parte 1


Membros estaticos são membros da classe, e eles não precisam de objetos para serem chamados e sim apenas a classe, como por exemplo o "Math.sqrt()", aqui é um exemplo de membro estatico , eu não preciso ter um objeto instanciado para executalos, ou chamalos.


Dica : NÃO É possível CHAMAR métodoS QUE NÃO SEJAM ESTATICOS DENTRO DE UM OUTRO método ESTATICO, POR EXEMPLO CHAMAR UM método QUE NÃO SEJA STATICO DENTRO O PROGRAMA PRINCIPAL, SE ELE PERTENCE A UMA CLASSE E TEM UMA INSTANCIA BELEZA CASO CONTRARIO ESQUECE, métodoS ESTATICOS SÓ PODEM SER CHAMADOS DENTRO DA PROPRIA CLASSE AO QUAL ELES PERTENCEM.


E para declara constantes é bem simples é só mandar um "public static final" e declarar o nome da constante tudo em letras maiusculas.

Aqui eu intendi que na real tudo depende de onde e como você vai utilizar, depende da necessidade de negócio da sua aplicação, porque os dois jeitos funcionam, e ainda tem o terceiro que vai ser apresentado na aula 2.


70. Membros estáticos - Parte 2


Aqui ele deixou tudo como estava basicamente, porque ele voltou tudo para "static" mais ainda assim ele deixou dentro da classe, acho que tudo que tenha uma formula e que essa formula não mude pode ser deixado como "static" claro que as vezes não é tão rapido e pratico assim mais da para fazer.


Aqui basicamente ele criou métodos porém com a diferença de não precisar instanciar nenhum objeto só chama ele com o nome da classe e o nome do método.



71. Exercício de fixação

Aqui na real não intendi muita coisa, só que eu fiz tudo certo e no final das contas não deu certo, acho que o eclipse estava tudo bugado, eu não conseguia executar as paradas direito,acho que ele tava com informação na memoria e conflitava com a que eu queria executar.

além disso eu não intendi o porque dele colocar o valor do IOF que era uma porcentagem para ser multiplicado e ainda somar esse valor com 1.0, mais vamo ai.



Seção 9: Construtores, palavra this,sobrecarga, encapsulamento

72. Visão geral do capítulo


73. Material de apoio do capítulo


74. Construtores

Todas as classes tem um método construtor e ele é executado na hora que instanciamos a classe, quando utilizamos o "new" ele é acionado para fazer a construção/instacição do objeto na memoria.

Basicamente todos os objetos possuem um método construtor padrão,  e ele não espera nada como parâmetro de entrada, porém é possivel previnir possiveis erros na hora da utilização da sua classe, criando um construtor.

assim esse construtor que você criou vai sobrescrever o default e toda vez que alguém for utilizar sua classe(instanciar) ele vai ser obrigado a passar todos os parâmetros que sua classe precisa porque você obriga isso na instanciação.


Nessa aula ele alterou o código de gerenciamento de estoque, fazendo com que na hora da construção eu seja obrigado a passar todos os parâmetros do objeto, porque segundo a lenda não faz sentido eu criar um objeto vazio primeiro para depois passar os valores para dentro dele,só que também não faz sentido criar variaveis temporarias para isso, mais cada louco com suas loucuras.


São os Arquivos que estão no projeto "aula_65".


75. Palavra this

Palavra this serve para diferenciar atributos de variaveis locais, ou seja quando dentro do método eu uso "this.algumaCoisa" eu to falando que esse meu atributo é valor que foi passado para o objeto e não o que está na variavel local do programa, ou seja eu não corro o risco de pegar um valor que já pode ter sido alterado, e vou pegar o valor que foi passado para o objeto.


Também da para usar o "this" para passar um objeto como argumento/parâmetro dentro de uma função.


76. Sobrecarga

Aqui eu vou criar um projeto novo para essa aula usando o que já ta pronto da aula_65 e que foi modificado na aula 74, acho melhor e evita erros no eclipse, até porque isso é como se fosse um repositório meu, um lugar onde eu posso voltar para buscar informações e esclarecimentos.

Aqui basicamente ele mostra que sobrecarga é o processo de disponibilizar mais de uma forma de instancia de uma mesma classe, ou seja eu consigo ter uma mesma classe que obriga o cara a digitar o nome e a idade e também é possivel eu criar um objeto dessa classe passando apenas o nome, poruq eu tenho varios metodos construtores  que possibilitam isso, na pratica é para o caso de eu por exemplo fazer uma operação matemática onde eu não tenha algum dos valores e tenha que descobrir esse valor ai utilizo o construtor que não obriga a passagem dele e fecho.


77. Encapsulamento

Consistem em esconder informaçãoes importantes da aplicação ou até acesso a dados da classe, expondo as apenas por meio de uma operação segura.

O objeto deve sempre estar em um estado consistente e a classe deve garantir isso, fazendo com que qualquer dado que entre na classe entre por um determinado acesso.


ou seja só deve receber dados via get() e set() FODA-SE.


78. Gerando automaticamente construtores, getters e setters com Eclipse

Aqui é bem simples na real vai no eclipse e clica no botão direito vai em " source -> Generate Constructor using Fields " isso para gerar os construtores e ainda você escolhe quais parâmetros você vai colocar no seu construtor.

para gerar os Getters e os Setters vai em " source -> Generate Getters and Setters " e escolhe também quais parâmetros você que seja criado os getters e setters.


79. Modificadores de acesso

private: o membro só pode ser acessado na própria classe

(nada): o membro só pode ser acessado nas classes do mesmo pacote

protected: o membro só pode ser acessado no mesmo pacote, bem como em

subclasses de pacotes diferentes

public: o membro é acessado por todas classes (ao menos que ele resida em um módulo diferente que não exporte o pacote onde ele está)



81. Correção do exercício de fixação - Parte 1

Basicamente eu não tinha percebido que aqui ele já queria que eu usase encapsulamento e que na real a regra era toda em apenas uma classe, acho que preciso mesmo focar em logica de programação.



82. Correção do exercício de fixação - Parte 2

Aqui ele termina a explicação do exercicio, na real é até que bem simples mais tenho que mudar minha cabeça quando se trata de programação, ainda penso estruturado e fico meio perdido na hora de codar uma classe e pensar em como funciona, mais a pratica leva a perfeição e assim começando cedo termina cedo.


Seção 10: Comportamento de memória, arrays, listas
83. Visão geral do capítulo
84. Material de apoio do capítulo

85. Tipos referência vs. tipos valor

Aqui basicamente o que ele disse foi o seguinte, que são do tipo referência todas as classes porque quando eu estancio uma classe ela na realidade recebe um valor de memoria que indica exatamente onde os valores daquele objeto está, ou seja na memoria STACK ele fica com o valor de memoria HEAP onde estão todos os valores daquele objeto.

isso é chamado de alocamento dinamico de memoria.

quando inicio uma variavel com tipo mesmo, na memoria STACK fica o valor propriamente dito, porque ele não precisa de mais espaço ele é o que é.

e toda variavel de tipo valor tem que ter sido inicializada com um valor, porque se não a propria IDE já avisa que vai dar erro.


Tipos referência vs. tipos valor
CLASSE 
Vantagem: usufrui de todos recursos OO

Variáveis são ponteiros

Objetos precisam ser instanciados usando new, ou apontar para um objeto já existente.

Aceita valor null

Y = X;
"Y passa a apontar para onde X aponta"

Objetos instanciados no heap

Objetos não utilizados são desalocados em um

momento próximo pelo garbage collector

TIPO PRIMITIVO

Vantagem: é mais simples e mais performático

Variáveis são caixas

Não instancia. Uma vez declarados, estão prontos para uso.

Não aceita valor null

Y = X;
"Y recebe uma cópia de X"

"Objetos" instanciados no stack

"Objetos" são desalocados imediatamente quando

seu escopo de execução é finalizado 


86. Desalocação de memória - garbage collector e escopo local

garbage collector é um assistem de desalocação dinamica de memória, o que ele faz basicamente ele fica meio que escaneando o código para tentar encontrar variaveis que foram instanciadas e perderam a referencia, ou seja estão na memoria STACK porém apontam para o mesmo lugar na memória HEAP


Desalocação por escopo é quando eu tenho um escopo de execução seja uma função  ou um if, quando eu declarar variaveis dentro do escopo dessa função ou desse if a variavel só existe ali, e após a execução desse cara essa variavel é desalocada , mais não pelo garbage collector e sim porque o escopo onde aquela variavel foi declarada terminou sua execução.

OBS. garbage collector só existe para limpar objetos que não estão mais em uso da memória, porque variaveis normais com escopo local são removidas da memória imediatamente após o termino do escopo.



87. Vetores - Parte 1

Basicamente é chamado de vetor porque ele tem apenas valores na vertical, e em inglês fica array porque o nome do vetor seria arranjo de valores, dai o array.

esse cara quando você cria ele e passa a quantidade de valores que ele vai ter dentro dele ela automaticamente já cria na memoria espaço para a quantidade de valores que você colocar.

obs. padrão array começa com 0.

vantagens é que se eu tentar acessar qualquer posição dele eu consigo facilmente.

desvantagens é que se eu precisar remover um valor do meu array eu sou obrigado a jogar todos os outros valores para cima o que da muito trabalho , isso claro falando de valores no meio do array , se for o 1 item do array ou o ultimo é mais facil.

Felizmente não tem muito como correr para percorre um vetor segue ainda aquele padrão for.



88. Vetores - Parte 2

Aqui ele mostrou como se cria um array de objetos, basicamente como a maioria das coisas no java é referencia e memoria, o array de objetos também é, aqui você primeiro cria um array passa para elea quantidade de itens que ele vai ter e quando for para atribuir os valores para dentro do array você passa uma instancia de um objeto, ai ele vai armazenar naquela possição a referencia de memoria daquele objeto que foi instanciado.

É meio complicado e meio dificil de intender mais ao mesmo tempo faz um sentido pela arquitetura da linguagem, como ela sempre tem a parada de referenciar objetos com suas posições na memoria nos vetores não foi diferente, acho que fica meio complicado fazer assim mais vamos que vamo.


89. Exercício de fixação

Já fiz o exercicio e commitei no repositório.


90. Boxing, unboxing e wrapper classes

Boxing é o processo de criar um objeto apartir de uma variavel de tipo primitivo, ou seja eu tenho uma variavel int e com ela eu crio uma um novo objeto que recebe o valor dela.

unboxing é quando eu crio uma variavel de tipo primitivo apartir de um objeto no caso eu preciso fazer o casting para o tipo equivalente do dado para dar certo.

wrapper classes são classes padrão do java que servem para que eu consiga tornar todas as minhas variaveis de tipos primitivos em objeto para que não de erro quando eu for fazer o meu programa.

basicamente esses caras aqui são utilizados para fazer com que eu consiga converter variaveis de tipos primitivos em objetos e que eu consiga armazenas valores nullos nelas, porque as variaveis de tipos primitivos padrão não aceitam nulo.

OBS. toda variavel de tipos primitivo tem uma wrapper class correspondente, para que seja possivel utilizar esses caras sem fazer canting .


91. Laço for each

O for each é uma estrutura de repetição que executa enquanto tiver intens dentro de uma coleção(array), e ele tem quase a mesma syntax do for normal.

for(tipo apelido : coleção){

}

é um pouco mais simples do que o for mais não sei qual as vantagens de usar ele.

92. Listas - Parte 1

Listas são estruturas de dados homogeneos ou seja sempre os valores são do mesmo tipo, e todas as listas iniciam vazias e eu posso ir alocando novos itens conforme necessidade, e tem mais cada item da lista conhece tem uma referencia para o proximo nodo(no), e os itens da lista são ordenados e acessados igual array.

toda lista é do tipo 'List' e esses caras são Interfaces

(Interface são classes que definem um padrão de campos e do que vai ser utilizado o B.O é que tem que ser instanciado apartir de uma classe.)

Vantagens de usar List
    tamanho flexivel
    facilidade para se realizar inserções e deleções
Desvantagens
    Acesso sequencial aos elementos

essa parada de acesso sequencial é o seguinte se eu quiser pegar o item 3 da minha lista eu preciso percorrer ela toda , passando por todos os elementos até chegar na posição que eu quero, isso ai da muita merda, mais tem alguns tipos de busca otimizada nas listas por exemplo o ArrayList, que é uma mistura de array com lista que permite percorrer a lista como se fosse um array.

Aqui como o tipo List é uma interface eu preciso de uma classe que implemente essa interface porque eu não consigo instanciar uma interface(acho que em nenhuma linguagem da para fazer isso)


93. Listas - Parte 2

Tamanho da lista: size()

Obter o elemento de uma posição: get(position)

Inserir elemento na lista: add(obj), add(int, obj)

Remover elementos da lista: remove(obj), remove(int), removeIf(Predicate)

Encontrar posição de elemento: indexOf(obj), lastIndexOf(obj)

Filtrar lista com base em predicado:List<Integer> result = list.stream().filter(x -> x > 4).collect(Collectors.toList());

Encontrar primeira ocorrência com base em predicado:Integer result = list.stream().filter(x -> x > 4).findFirst().orElse(null);



94. Exercício proposto

Finalizei o exercicio mais tive que pegar o exemplo dele, porque eu ainda não peguei direito como usar array e listas.


95. Matrizes

Aqui basicamente ele fez uma revisão  mostrando o que são matrizes, que na real é um vetor de vetores, um array bidimensional, ou um array com outros arrays dentro, formando quase que uma tabela.


96. Exercício resolvido

Aqui ele resolveu um exercicio onde eu setava valores para uma matriz, onde o usuario passa a quandidade de linhas e colunas da minha matriz, ai eu tenho que atribuir esses valores no array interno e na possição em que foi digitado, é relativamente simples, o problema é que se não treinar e se não correr atrás nunca vai pegar e sempre vai se lascar quando precisar utilizar.

mais uma parada que eu preciso fortemente estudar, sei la começar a resolver exercicios basicos da net mesmo e ver como eu me saio.

Seção 11: Tópicos especiais em Java

98. Material de apoio do capítulo

99. Trabalhando com datas - Date

Aqui o cara apresenta varias formas de como se trabalhar com data no JAVA, tem as paradas normais mais tem classes especificas para isso, que já são proprias para isso e que ainda auxiliam na formatação dos campos data, o b.o é que nego precisa de pelo menos umas 15 classes para conseguir fazer a formatação    


100. Manipulando um Date com Calendar

Basicamente a classe Calendar tem um monte de metodo, para todos os tipos de manipulação de data, ele deu alguns exemplos pegando dia, e minutos para exemplificar que é possivel, mais eu achei meio imbassado que na real eu sempre preciso setar uma variavel com do Calendar, ai eu pego a data que eu setei e ai passo ela para o calendar, ai eu começo a trabalhar e usar as funções do calendar para manipular data, muia volta para pouca coisa na real.



Seção 12: Bônus - nivelamento sobre Git e Github

101. Visão geral do capítulo Git e Github

102. Material de apoio do capítulo


103. O que é Git e Github

Bem padrão explicou o que é cada um deles e explicou o que é o que faz.

104. Instalação do Git no Windows

Padrão


105. Demo - criando um novo projeto

Mostrou o passo a passo de como criar um repositório local e um remoto e como sincronizlos, além do passo a passo de como subir arquivos para seu repositório remoto e todo paranaue envolvido.

106. Arquivo .gitignore

Explicou que serve basicamente para não versionar arquivos que realmente não precisam ser versionados.


107. Demo - trabalhando com um projeto existente

Aqui ele mostrou como subir alterações no repositório que já possuem alterações e coisas, ai você precisa baixar tudo o que tem no remoto e ai você corrige / altera e sobe


108. Importante entender - a sequência de commits deve ser respeitada

Aqui ele fala que você precisa sempre trazer tudo que está no seu repositório remoto para o seu local, porque se não vai dar conflito nas linhas do commit, e ai você vai ter que fazer o merge ta porra toda.


109. Kit de primeiros socorros

Aqui ele gerou uma listinha com os comandos mais uteis em caso de problema no repositório, apagar alterações e tals.



Seção 13: Enumerações, composição

110. Visão geral do capítulo Enumerações e Composição

111. Material de apoio do capítulo


112. Enumerações

Tipos enumerados são basicamente utilizados para armazenar estados, e para representar com UML só coloca uma anotação emcima do nome da classe informando que é um enum e passa os nomes que você vai aceitar, e na sequencia passa os valores corresponentes aos seus estados.


113. Vamos falar um pouco sobre design

Aqui ele apresenta os tipos de classe que existem no java e que na real por enquanto vamos utilziar as entities mesmo porque era o que estavamos utilizando até agora mais tem muitas, tem todo o esquema do MVC .


114. Composição

Aqui ele da uma introdução teorica sobre composição, e fala que classes que tem dependencia ou que juntas compoem um sistema tem o nome de composição, por exemplo a composição de um objeto pedido eu tenho um objeto cliente +/- isso.


115. Exercício resolvido 1 - Parte 1

Aqui ele começa a apresentar os conceitos de composição quando uma classe tem associação com outra, e ai como funciona ele vai criando varias classes separadas cada uma com sua reponsabilidade, e com seus respectivos dados, sempre permitem ou não acesso aos dados.

tem 4 classes mais a principal que vai usar tudo isso e apresentar para o usuario,é um meio complicado no começo mais quando começa eu começo a pensar nos conceitos de O.O ai vai ficando mais facil de intender o que e como é para ser feito..


116. Exercício resolvido 1 - Parte 2

Aqui ele conclui o programa, e mostra como é bem simples fazer a associação de classes , claro primeiro precisa ficar bem claro na sua cabeça a ordem como tudo vai funcionar se não você vai se perder nas associações, por isso acho que é bem importante ter um modelo visual de como tudo vai funcionar e se relacionar(associar).

acho que quanto mais eu praticar e estudar melhor eu vou ficar.

funciona o programa,acho que eu consigo mandar isso em qualquer lingaguem e em qualquer projeto só focar em como eu devo fazer e aprender a como fazer na ferramenta e na linguagem que eu trabalho.


117. Exercício resolvido 2 (demo StringBuilder)

Aqui ele criou um esquema de Post e comentarios na pegada de blog, foi um exemplo de como usar a composição de classe e ainda mostra a classe stringBuilder, na real essa classe serve para que você não tenho que ficar igual um demente colocando aspas("") e mais (+) na sua system.out.println, a propria classe tem um metodo que se chama "append()", que serve justamente para isso, e ai você consegue ir colocando texto nesses append's e vai criando seu texto.


118. Exercício de fixação


Na real eu até consigo compreender o que ele fez e ir acompanhando mais não da para continuar assim , preciso treinar mais, focar em resolver exercicios,porque acredito que do jeito que o mano faz deve facilitar e muito o desenvolvimento além de que pode ser o jeito mais rapido e prático de se desenvolver programas.


#FOCONOSESTUDOS


Seção 14: Herança e polimorfismo

119. Visão geral do capítulo Herança e Polimorfismo


120. Material de apoio do capítulo


121. Herança

Herança é quando uma classe herda os atributos e metodos de uma outra classe, o que significa que todas as vezes que eu instanciar uma classe que é extenção de uma outra eu não crio duas classes como na composição mais sim apenas uma classe com todos os atributos e metodos das duas classes.

Conceitos em Herança

"é um" -> quer dizer que um carro "é um" automovel, ou seja carro é um automovel assim como caminhão é um automovel, isso é utilizado para pensar em se devemos usar herança ou composição.

Generalização / espeicialização -> quer dizer que a classe pai ou super classe é o tipo mais basico de um objeto e por isso é a Generalização e o que seus filhos são especializados em fazer alguma coisa por isso espeicialização.

Superclasse (classe base) / Subclasse (classe derivada) -> A super classe como dito no conceito acima é a classe pai que dela na teoria vem todos os atributos e metodos que todos devem ter por isso é a super, e ai entra aquele esquema que o eclipse coloca de "super();" esse cara é o que garante que todos as propriedades da classe pai estejam nos filhos, e subclasse é a classe filha que extende de uma outra classe mais generica, e que na teoria deve ser especializada em alguma coisa.

Herança / extensão -> como eu estou literalmente extendendo uma classe com seus metodos e atributos e acrescendo mais coisa nela essa classe filha é uma extensão da classe pai.

Herança é uma associação entre classes e não entre objetos -> como tido em algum lugar acima quando eu instancio uma classe extendida eu não crio dois objetos mais um só isso siginifica que elas são uma parte da outra não da para instanciar um carro sem que ele já venha com as paradas do automovel.

Aqui faltou apenas colocar que quando o uso correto dos modificadores de acesso também impacta na hora da codificação, porque se eu preciso mexer em um atributo de um classe mais esse atribtuto vem da classe pai, ele tem que estar como protected.


122. Upcasting e downcasting

Aqui é bem simples a parada, quando eu to fazendo o Upcasting eu to criando uma instancia de um objeto filho e jogando ele dentro de uma instancia do objeto pai.

ou seja eu tenho uma businessAccount que é um filha de Account, e ai eu crio uma businessAccount mais como tipo dela Account, fazendo com que ele seja literalmente um businessAccount do tipo Account, mais por dentro é uma businessAccount.

e o downcasting é o contrario, eu to criando um objeto do tipo businessAccount e/ou qualquer outro objeto de um tipo filho e tento atribur um objeto pai nele, o que por si só da um erro de compilação, a menos que eu crie o Casting manual informando o tipo daquele objeto para que não de erro.

basicamente essas duas loucuras aqui são para você criar instancias de um determinado tipo mesmo que na verdade o objeto seja de um outro tipo, e pelo que eu vi isso só da para fazer com classes pai e filhas.



123. Sobreposição, palavra super, anotação @Override


Aqui é o seguinte, existe duas paradas, Sobreposição é quando eu implemento um metodo de uma Superclasse em uma subclasse, porém não é possivel alterar os parâmetros nem o retorno mais é possivel mudar o comportamento para que atenda as minhas necessidades.

tem a Sobrecarga que eu consigo mudar tudo, até mesmo os parâmetros.

Aqui tem uma sacada do JAVA que ele utiliza uma anotação para indicar ao compilador que se trata de uma Sobreposição que é o "@Override", eu não sou obrigado a informar essa anotação mais como boa pratica e convenção é fortemente aconselhavel que seja utilizada.

Palavra super, é igual quando eu quero fazer um Upcasting ou Downcasting só que para metodos, eu utilizo o "super.nomeDoMetododaSuperClasse" assim eu consigo utilizar os metodos da Superclasse nas filhas, e até mesmo mudar o comportamento igual o mano fez na aula.

124. Classes e métodos final

Aqui basicamente ele mostrou para que serve a palavra final e que é possivel utilizar ela tanto em classes quanto em metodos.
Basicamente serve para imperdir que uma classe quando ela for final ela não consiga ser herdada por mais ninguém, e o mesmo acontece com quando um metódo tem o "final" no seu nome, ele disse que basicamente isso se aplica quando a regra de negócio necessita, e quando você precisa de uma certa agilidade em tempo de execução porque alguns tipos de dados são executados mais rapidamente quando estão em classes finais.



125. Introdução ao polimorfismo

Aqui ele mostra que o mesmo esquema que já tinha sido feito anteriormente já serve como um exemplo de polimorfismo, porque eu vou ter dois objetos do mesmo tipo chamando metodos com o mesmo nome porém com comportamentos diferentes.

no exemplo da aula não fica igual estou acostumado a ver que é duas instancias da mesma classe com o mesmo tipo chamando os mesmos métodos terem comportamento diferente, mais ainda assim deu mais uma exemplificada.

126. Exercício resolvido

Aqui ele mostra como fazer a parada do polimorfismo de método em um exemplo bem simples, além de ajudar mostrando novamente as paradas das listas, vou ter que estudar ainda mais sobre listas , arrays, Sobreposição e sobrecarga mais isso sempre.


127. Exercício de fixação

Consegui fazer o exercicio praticamente todo, claro que fui seguindo a aula passada mais ainda assim consegui fazer, o que achei meio sacanagem é que ele inicia o contador em "1" para conseguir deixar o contador certo, e que na hora de devolver a data eu tava usando o "getManufactureDate" quando na verdade era usa o proprio atributo "manufactureDate" que dava certo usando o "SimpleDateFormat"


128. Classes abstratas

Classes abstratas são classes do tipo mais generico possivel, elas não podem ser instanciadas porque devem ser genericas ,e só podem ser herdadas e polimorfadas, funcionam mais ou menos como um esqueleto, você consegue utilizar tudo que está la, e consegue usar ela em qualquer lugar desde que não utilize uma instancia dela e sim uma herança.


129. Métodos abstratos

Métodos abstratos são metodos que não possuem implementação, ou seja eles obrigatóriamente devem ser polimorfados, eles sõa utilizados quando a classe é generica de mais para conter sua implementação.

Obs. se a classe tiver um método abstrato obrigatóriamente essa classe vai ser abstrata, e a representação de método e classe abstrata em UML é com nome em italico.


130. Exercício de fixação

Exercicio finalizado com alguns inroscos, mais nada muito complicado tive que dar uma olhada porque eu estava querendo fazer muito mais coisa do que precisava, acho que essa maturidade vem com o tempo.


Seção 15: Tratamento de exceções

131. Visão geral do capítulo Tratamento de Exceções

132. Material de apoio do capítulo

133. Discussão inicial sobre exceções

Uma breve introdução sobre exceções, existe no java uma classe que trata erros e exceções, essa classe tem uma hierarquia de tratamento e varios tipos de exceções, e por ser  uma classe ela pode conter atributos, o ideal é que quem deve tratar as execeções é a propria classe que contém a regra de negócio, mantendo assim aquele principio de responsabilidade clara, e é ideial que sejam tratados os erros ao invés de travar a aplicação.


134. Estrutura try-catch

Aqui ele apresentou a estrutura de try-catch que como eu coloquei direto no código serve mais ou menos como um if-else, porém para tratar erros e execeções, o que eu achei problematico, você precisa conhecer os tipos de erros que sua aplicação pode gerar ou sofrer para poder colocar porque se não ele não funciona, você pode mapear todos os tipos de erros que sua aplicação pode gerar mais ainda assim você vai precisar conhecer os nomes dos métodos de exceção para poder colcar uma ação que seu programa vai tomar quando ela acontecer.


135. Pilha de chamadas de métodos (stack trace)

Essa parada de stack trace, serve para mostrar exatamente onde aconteceu o erro, ele vai mostrando desde onde ocorreu o erro até sua classe "main", no exemplo do aula ele criou dois métodos e um chamava o outro, e dentro deles ocorreu um erro e ele tinha colocado para ser apresentado o stack trace, que nada mais é que aquelas informações de erro que aparecem no console da aplicação, porém quando se usa o try-catch não encerra a aplicação na hora em que ocorre um erro, porque na teoria você tratou aquele erro e mandou seu programa tomar alguma alção quando ele acontecer, porém esse stack trace serve só mesmo para isso para mostrar onde deu o erro igual no console normal do java, mais como vai estar dentro de um try-cathc ele não vai terminar a execução da aplicação.


136. Bloco finally

Esse cara aqui serve basicamente como um "default" do switch-case, porque ele vai ser executado independente de sucesso ou erro na execução da sua aplicação, e como no exemplo eu teria que fechar o arquivo , coloca o bloco "finally" e nele coloca o que for preciso mesmo ser executado.


137. Criando exceções personalizadas

Aqui ele já vai começar a trabalhar com versionamento do GIT, ele vai criar um repositório e colocar todas as versões de tratamento de execeções tanto a muito ruim quando mais indicada, acho que vai ser meio osso ficar escrevendo diretó no código mais ai vou tentar detalhar o melhor possivel aqui mesmo no arquivo de notas.

Reservation.java

Por enquanto ele só fez a classe "Reservation.java" e que tem minhas considerações.
	/*
	 * Aqui é uma parada de uma classe nova, ele mostrou que é possivel calcular
	 * datas atrás de milisegundos e que isso é muito usado no java, aqui ele ta pegando a data que foi digitada 
	 */
	public long duration() {
		long diff = checkOut.getTime() - checkIn.getTime();
		return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
	}



	/*
	 * Aqui basicamente ele fez o simples e colocou um método toString para poder
	 * retornar os dados, mais ainda não tem tratamento nenhum de nada, pelo que eu
	 * vejo.
	 */
	@Override
	public String toString() {
		return "Room " + roomNumber + ", check-in: " + sdf.format(checkIn) + ", check-out: " + sdf.format(checkOut)
				+ ", " + duration() + " nights";
	}


138. Primeira solução - muito ruim

Aqui ele diz que a solução é muito ruim porque toda a logica de negócio e toda solução está no programa principal, que segundo ele é pésimo, eu até concordo mais acho que não teria problemas, o que impacta é que sempre que você precisar mudar alguma regra vai ter que mexer no programa principal.


Program.java


	/*
		 * Aqui toda logica fica no programa principal, o que segundo ele é um problema
		 * e uma pessima solução.
		 * 
		 * 
		 * Aqui a classe "DATE" tem um método que permite ver se a data é antes ou
		 * depois de uma data que informe, por isso que tem o "checkOut.after()" e o
		 * "checkOut.beforer()"
		 */

		if (!checkOut.after(checkIn)) {
			System.out.println("Error in reservation: Check-out date must be after check-in date");
		} else {
			Reservation reservation = new Reservation(number, checkIn, checkOut);
			System.out.println("Reservation: " + reservation);

			System.out.println();
			System.out.println("Enter data to update the reservation:");
			System.out.print("Check-in date (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.print("Check-out date (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());

			/*
			 * Aqui a validação vai nos valores das variaveis mesmo, e na comparação com uma
			 * data que foi setada na mão ali na variavel "now".
			 */
			Date now = new Date();
			if (checkIn.before(now) || checkOut.before(now)) {
				System.out.println("Error in reservation: Reservation dates for update must be future dates");
			} else if (!checkOut.after(checkIn)) {
				System.out.println("Error in reservation: Check-out date must be after check-in date");
			} else {
				reservation.updateDates(checkIn, checkOut);
				System.out.println("Reservation: " + reservation);
			}
		}


139. Segunda solução - ruim

Aqui ele passou quase toda a validação que existia no programa principal para a classe que na real tem que ser responsavel por fazer essas validações, e ai teve que fazer algumas mudanças porque o método que retorna agora retorna uma "String" o que na teoria gera um outro problema, que é a possibilidade de não retornar uma "String" porque deu tudo certo e ai eu fui obrigado a colocar um retorno de método nulo.


Program.java



package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

import model.entities.Reservation;

public class Program {

	public static void main(String[] args) throws ParseException {

		Scanner sc = new Scanner(System.in);
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

		System.out.print("Room number: ");
		int number = sc.nextInt();
		System.out.print("Check-in date (dd/MM/yyyy): ");
		Date checkIn = sdf.parse(sc.next());
		System.out.print("Check-out date (dd/MM/yyyy): ");
		Date checkOut = sdf.parse(sc.next());

		if (!checkOut.after(checkIn)) {
			System.out.println("Error in reservation: Check-out date must be after check-in date");
		} else {
			Reservation reservation = new Reservation(number, checkIn, checkOut);
			System.out.println("Reservation: " + reservation);

			System.out.println();
			System.out.println("Enter data to update the reservation:");
			System.out.print("Check-in date (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.print("Check-out date (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());

			/*
			 * Aqui tinha todas as validações mais como essas validações de reserva foram
			 * para a classe certa que é a de validação fica menos pior.
			 */
			String error = reservation.updateDates(checkIn, checkOut);
			if (error != null) {
				System.out.println("Error in reservation: " + error);
			} else {
				System.out.println("Reservation: " + reservation);
			}
		}

		sc.close();
	}
}



Reservation.java


package model.entities;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class Reservation {

	private Integer roomNumber;
	private Date checkIn;
	private Date checkOut;

	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public Reservation(Integer roomNumber, Date checkIn, Date checkOut) {
		this.roomNumber = roomNumber;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	public Integer getRoomNumber() {
		return roomNumber;
	}

	public void setRoomNumber(Integer roomNumber) {
		this.roomNumber = roomNumber;
	}

	public Date getCheckIn() {
		return checkIn;
	}

	public Date getCheckOut() {
		return checkOut;
	}

	public long duration() {
		long diff = checkOut.getTime() - checkIn.getTime();
		return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
	}

	/*
	 * Aqui ele trocou o método para "String" e passou toda lógica que estava antes
	 * no programa principal para cá, ainda ficou coisa la mais já tem mesmo o
	 * principio de responsabilidade clara, que quem tem que ficar com as regras de
	 * reserva é a classe de reserva, o B.O é que na real ainda devolvo uma
	 * "String", o que segundo a lenda é zuado, e como pode ser que eu tenha que
	 * retornar nada porque deu tudo certo ao invés de uma "String" eu preciso
	 * mandar retornar nullo no método.
	 */
	public String updateDates(Date checkIn, Date checkOut) {
		Date now = new Date();
		if (checkIn.before(now) || checkOut.before(now)) {
			return "Reservation dates for update must be future dates";
		}
		if (!checkOut.after(checkIn)) {
			return "Check-out date must be after check-in date";
		}
		this.checkIn = checkIn;
		this.checkOut = checkOut;
		return null;
	}

	@Override
	public String toString() {
		return "Room " + roomNumber + ", check-in: " + sdf.format(checkIn) + ", check-out: " + sdf.format(checkOut)
				+ ", " + duration() + " nights";
	}
}



140. Terceira solução - boa

Aqui ele separou a responsabilidade de cada classe, deixando o programa principal sem nenhuma validação nem regra de negócio e ainda trata todos os tipos de erros, porque ele trata os erros conhecidos e o desconhecido ele manda uma execeção generica.

é a ultima versão do programa que tá na pasta.


141. Exercício de fixação

Terminei a o exercicio como sempre colando o exercicio anterior, mais que desenrolei quase tudo solo, mais vendo o dele é bem interresante também, porque ai fico pouca coisa mais organizado, mais ta legal o meu também.


Seção 16: Projeto: Sistema jogo de xadrez

142. Visão geral do capítulo Sistema Jogo de Xadrez
Carai boracha , parece ser bem loko essa parada, agora eu animei com o javinha.

143. Material de apoio do capítulo

144. Dica importante para erros funcionais no projeto

Eu não tinha visto essa aula, não sei que merda aconteceu, mais pulei sem querer saporra, e ainda era mais ou menos dicas de como seguir com os projetos.


145. Criando projeto e repositório Git

Mano aqui ele sugeriu criar um repositório novo para o jogo de xadrez, acho que vou criar esse novo repositório mais vou deixa-lo como um submodulo, igual ficou o ultimo modulo la dele.


146. Primeira classe - Position

Primeira Aula apenas a criação de uma classe de posição que vai mostra a posição das peças na tela.


147. Começando a implementar Board e Piece

Aqui fez a inserção de mais duas classes para o programa de xadrez, a unica coisa que tem aqui de importante por enquanto é a modelagem que ele fez e utilizou.

148. Camada Chess e imprimindo o tabuleiro

Nessa aula printamos o tabuleiro de xadrez, e criamos a logica de apresentação das pessas, como ainda não tinha peça nenhuma ficou tudo como traço(-), mais as proximas implementações acho que resolvemos isso.

149. Colocando peças no tabuleiro

Aqui já criamos duas peças o rei e a torre, ainda bem simples sem regras sem nada apenas a classe e o retorno dela, o posicionamento ainda é manual mais ja funciona.

OBS. Tive problemas por não copiar corretamente as classes, perdi ai uns 30 min voltando e procurando onde tava o erro.


150. BoardException e programação defensiva

Criamos uma classe de execeção personalizada, e adicionamos validações para evitar que de erro na instanciação, colocar as peças dentro do tabuleiro, não deixar peças sobre peças.


151. ChessException e ChessPosition

Basicamente foi muita coisa, mais ta ficando cada vez mais interessante, porque agora convertemos valores de um tabuleiro em posições de uma matriz e vice versa, além de que temos agora Exceptions personalizadas

152. Pequena melhoria na impressão do tabuleiro

Mudamos aqui para apresentar as peças no tabuleiro com cor diferente,e agora para visualizar essa alteração precisaremos abrir ele no terminal do sistema operacional ou abrir o terminal no eclipse.

OBS. Estou com alguns penos problemas por ainda não ser muito pro nessa parte de SUBMODULO, é a segunda vez que perco informações de um commit, para o outro, tenho que sempre tomar cuidado para não tomar na taraqueta.

153. Movendo peças

Aqui adicionamos os métodos para poder mover as peças, é até que bem simples, primeiro capturamos as posiçoes de xadrez e passamos para um método que vai verificar se existe peça naquela posição de origem, se não houver execeção, se houver remove ela de la, e verifica se tem alguma peça na posição destino, ai remove a posivel peça que estiver la e já coloca a peça removida da origem no destino.


154. Tratando exceções e limpando a tela

Apenas adicionamos um código da net que fica llimpando a tela impedindo que fique com scroll, e adicionamos tratamento de execeções no programa principal.


155. Movimentos possíveis de uma peça

Aqui começamos a verificar quais seriam os movimentos possiveis de uma peça, claro que cada peça e responsavel por informar para onde que ela vai, mais ainda assim começamos a fazer as validações para ver quais são os movimentos possieis de cada peça e para saber onde que a peça está e dados os movimentos possieis de cada peça e sua posição daremos uma mensagem de erro se ela estiver presa.

156. Implementando movimentos possíveis da Torre

Adicionamos todas as movimentações posiveis da torre, é meio complexo e complicado mais bem simples depois de pensar direitinho.

OBS. o meu programa depois de dar uma exceção sempre mostra a mensgem de que .

Tinha eu corrigi todos os erros.


157. Imprimindo os movimentos possíveis

Aqui já pintamos o fundo de cada movimento possivel após selecionarmos uma peça qualquer, é meio confuso sim, mais nada que não de para entender.

158. Implementando os movimentos possíveis do Rei

Aqui estamos implementando todos os movimentos possiveis de um rei, é muita coisa porque tem que colocar todas as direções e posições possiveis em que ele pode se mover, mais ao mesmo tempo é ver na matriza as posições o resto é bem tranquilo.

159. Trocando de jogador a cada turno

Aqui eu adicionei o método que mostra em qual rodada estamos e qual é o jogador da vez além de validar quem ta jogando para que não mova peças do adversario, foi até que simples mais mesmo sendo didatico acho que fica meio complicado fazer assim pedações de cada vez das classes.


160. Manipulando peças capturadas

Aqui tivemos que alterar algumas classes para poder fazer dar certo, mais agora estamos capturando as peças e jogando em listas e apresentando essas listas.


161. Lógica de xeque - PARTE 1

Colocamos uma logica que faz a validação para ver se existe um rei da cor do jogador no tabuleiro, caso não exista vai dar muito ruim e provavelmente acabar o jogo, mais tirando isso devemos conseguir validar a cor do rei e onde ele está no tabuleiro, além de poder também desfazer a jogada caso o jogador se coloque em posição de check o que não é permitido.


162. Lógica de xeque - PARTE 2

Finalizamosa logica de check, na real a primeira aula deixou tudo meio que encaminhando, ele aqui só criou um get para o check, e colocou no printMatch o check em caso de ser true.


163. Lógica de xequemate

Mano que bagaceira, coisa de maluco mesmo, foi e voltou umas trinta vezes, ele move as peças para as pocições que destino e depois desfaz e ve se ficou em check mate, sei la que porra doida que foi essa, acho que deve existir algumas coisas mais simples.


164. Contagem de movimentos das peças

Aqui criamos métodos para fazer a contagem dos movimentos das peças, e claro se necessario desfazer a jogado ele retira esse valor do contador.


165. Peão

Criamos a classe peão e adicionamos tadas as logicas relacionadas.


166. Bispo

Adicionamos o bispo e colocamos todas as regras dele.


167. Cavalo

Adicionamos o cavalo no jogo e todas as regras dele.


168. Rainha

Adicionamos o rainha no jogo e todas as regras dele, tinha um erro no peão preto que foi corrigido.


169. Jogada especial Roque - PARTE 1

Aqui é uma jogada especial chamada roque, que consistem em quando seu rei ainda não se mexeu nem as torres ai se as duas casas para os lados do rei estiverem vazias você pode se mover para la com o REI, mais só nesse caso e ainda essa jogada move a torre junto assim que tu mexe o rei, ficou faltando a implementaçao da regra no makeMove e undoMove.


170. Jogada especial Roque - PARTE 2

Aqui ele finaliza colocando a logica do makeMove e do undoMove, na real ele movemanualmente a torre em caso de roque.


171. Jogada especial en passant - PARTE 1

Aqui é mais uma jogada especial do xadrez, e que serve para capturas de peão, aqui vai mudar legal no arquivo de anotações porque eu percebi hoje que eu tinha pulado uma aula, e que todos os numeros de aula estavam errados, corrigi e pau no gato.


172. Jogada especial en passant - PARTE 2

Finalizando o moviemnto espeical En Passant colocando as movimentações dos peões pretos e brancos e fazendo os undoMove deles.


173. Jogada especial promoção

Aqui ele promove o peão que percorre o tabuleiro todo chegando até o outro lado fazendo ele virar qualquer outra peça que seja mais poderosa, foi bem interresante a forma como ele teve que ir criando metodos auxiliares para poder fazer a parada funcionar.


Seção 17: Trabalhando com arquivos

175. Visão geral do capítulo Trabalhando com Arquivos

176. Material de apoio do capítulo

177. Lendo arquivo texto com classes File e Scanner

interresante, tem classes especificas no java para leitura de arquivo, claro que meio que tu é obrigado a usar as paradas prontas, mais da para se virar, nada muito diferente do que em outras linguagens.


178. FileReader e BufferedReader

O FileReader é um "stream" (sequencia) de caracteres dentro de um arquivo, mais parece que ele não é muito otimizado, e deve ser meio lento quando utilizado solo

o BufferedReader é instanciado apartir do FileReader e ele implementa otimizações de leitura dessa sequencia de caracteres, o que faz com que sempre utilizemos os dois juntos.


179. Bloco try-with-resources

Essa parada aqui funciona assim, você instancia as suas classes que pode dar erro direto detro do bloco try, e ai você não precisa instanciar as suas classes nem dentro nem fora do try porque tudo vai estar no escopo do try, e não vai mais precisar do método finally com outro try, porque a instanciação está dentro do método try.

aqui basicamente serve para o tratamento de stream's para que você não precise ficar fechando as paradas.


180. FileWriter e BufferedWriter

Essas classes servem para escrever no arquivo ou criar um arquivo e escrever o conteudo nele caso ele não exista, e como as de leitura o BufferedWriter é otimizado, funciona igual, só que o BufferedWriter, não tem quebra de linha no comando "write()" então você é obrigado a usar o "newLine()" junto com ele para sempre que terminar ele quebre uma linha no arquivo.


181. Manipulando pastas com File

A clase file serve para manipular arquivos e diretórios , aqui nessa aula eu mostra mais ou menos como usar ela, é bem simples, não tem muito segredo.


182. Informações do caminho do arquivo

Aqui tem algumas das funcionalidades da classe File, que mostra o nome do arquivo apenas, mostra o caminho completo mais o nome do arquivo e que mostra só até o diretórios onde você está.


183. Exercício proposto

Bom não consegui fazer o arquivo, e percebi que eu não ia conseguir quando vi o exercicio resolvido, preciso mesmo de mais pratica e treino, depois olhando o dele é até simples e faz sentido mais ainda não penso assim.


Seção 18: Interfaces

184. Visão geral do capítulo Interfaces

185. Material de apoio do capítulo


186. Interfaces

Aqui ele trás uma breve introdução sobre o que é interfaces em java, e mostra que basicamente é uma classe abstrata com métodos abstratos, porém ele ainda vai discutir a utilização de ambas, e explicar quando e porque escolher uma ou outra, mais basicamente o que ele diz é que interfaces são como "CONTRATOS" que você deve seguri e respeitar ao implementar uma interface.


187. Solução do problema - PARTE 1

Aqui ele começou a fazer as implementações de classes sem as interfaces pelo que percebi e vai fazer assim para que seja possivel fazer o comparativo depois com a implementação das interfaces.


188. Solução do problema - PARTE 2 (sem interface)

Aqui ele fez as implementações com as classes apenas sem usar interfaces ainda , é meio comlexo essa parada de você instanciar objetos dentro da declaração de outro objeto gerando assim dependencia entre eles, mais é assim que o java se propoem a trabalhar.


189. Solução do problema - PARTE 3

Aqui o que aconteceu ele criou uma interface para que a classe "RentalService" faça a implementação do imposto, o que faz com que não importe o tipo de imposto ele sempre vai alterar só o imposto, ai deixa a classe com um baixo ou quase zero acoplamento, e na proprio programa principal eu posso passar o tipo do imposto na instancia do meu "RentalService" se tivesse mais de uma classe de imposto poderia passar ela ali também.


190. Inversão de controle e injeção de dependência

Inversão de controle - é quando uma classe não instancia todas as suas dependencias, fazendo assim com que não tenha um alto acoplamento

injeção de dependencia - é uma forma de Inversão de controle mais que consistem em fazer com que outra classe ou lugar instancie as dependencias de uma classe e "injete" essa dependencia na classe pai.


191. Exercício de fixação

Aqui tomei e tomaria mais um sacode, eu não tinha iniciado corretamente a classe com listas, o que me foderia no final, acho que me falta a vivencia basica do java de olhar listas e já pensar em ArrayList, mais clonei e deu tudo certo, preciso voltar pesado nesses pontos.


192. Herdar vs. cumprir contrato

Aqui ele mostra quais as diferenças entre herdar e cumprir contrato, como o nome já diz.

quando você herda você reutiliza partes daquela classe mais generica, e ai você não precisa reescrever o código, porém sempre que tiver você vai ser obrigado a implementar ou utilizar coisas que talvez a classe mais especializada não precisaria.

quando você cumpre o contrato você apenas implementa um método de uma interface e não reutiliza nada, apenas implementa o que tem no contrato.

tem ainda a implementação dos dois, você cria uma interface com o contrato e uma classe abstrata que vai conter o que precisa ser reutilizado, ai você faz a classe abstrata implementar a interface e ai quem herdar a classe abstrata vai ter que implementar a interface porque a classe abstrata obriga a isso, e ainda vai reutilizar tudo que tem na classe abstrata porque a classe abstrata obriga a isso.

como de costume eu to tomando um sacode no java, mais vou ficar pro nessa porra igual eu fiz com o PHP , HTML, CSS, e vou fazer com JS, Linux, BD.


193. Herança múltipla e o problema do diamante


Aqui ele explica que não é possivel herdar de duas classes diferentes no java, o que é possivel fazer é herdar de uma classe e implementar varias interfaces, o que não é considerado herança multipla porque não existe herança entre implementação de interfaces.


194. Interface Comparable

Essa interface comparable serve para comparar objetos com outros objetos, e quando você precisa comparar você tem que mostrar o que ele vai comparar, que ai funciona, é mais uma facilidade do JAVA que preciso aprender e utilizar para melhorar a qualidade do meu código.


195. Default methods

Aqui ele mostra que é possivel sim criar métodos em interfaces e que esses métodos podem ser reaporveitados em classes que implementam essas interfaces, claro que é uma parada mais complexa , é simples mais mal implementada deve dar muita bosta.


Seção 19: Generics, Set, Map

196. Visão geral do capítulo Generics, Set, Map

197. Material de apoio do capítulo

198. Introdução aos Generics

Aqui o generics é a respeito dos tipos de dados dentro de uma lista ou collection, o que ele faz ele simplesmente ao invés de instanciar uma lista com um tipo concreto , primitivo ou complexo ele instancia com um tipo generico que ele usa como exemplo "<T>" mais pode ser qualquer coisa, assim o tipo que eu declarar na instancia da minha lista acaba sendo o tipo da lista, o que permite que eu reutilize essa lista para todos os tipos de dados. 


199. Genéricos delimitados

Aqui ele mostrou que existem algumas operações que você vai precisar delimitar os tipos genericos, porque as vezes você vai querer comparar alguma coisa das suas listas, mais como ela é de um tipo generico você precisa fazer alguns ajustes na implementação para conseguir usar.


200. Tipos curinga


Tipos curinga pelo menos no exemplo que ele deu é o tipo curinga de uma lista é um '<?>' que isso aqui indica que na real pode ser de qualquer tipo, o que permite que eu instacie qualquer tipo de lista usando esse tipo curinga, só não consigo adicionar itens na lista porque o compilador vai dizer que não sabe se o itme que to tentando inserir na lista é do mesmo tipo que eu tenho na lista e por isso ele não deixa inserir itens novos.


201. Curingas delimitados


Aqui somos apresentados ao conseito de get/put ou covariancia/contravaiancia, que consistem em instanciar listas com tipos genericos ou tipos herdadados desse tipo generico(covariancia) , e quando é to tipo generico para o Pai do tipo generico(contravaiancia).

só é permitido acessar os dados da lista quando se faz a covariancia, tipo generico e subtipos dele

só é permitdo inserir dados dentro de uma lista quando se faz a contravaiancia que é do tipo generico para o supertipo dele.

De qualquer modo é sempre um extends ou um super e cada um permite um tipo de operação.



202. HashCode e Equals


Basicamente o Equals tem 100% de eficacia porém ele é mais lento , já o HashCode pode não ser 100% mais ele é bem mais rapido, então a implementação dos dois é deve ser sempre junta, que ai primeiro ele usa o HashCode para fazer a busca mais rapida e depois ele usa o Equals para poder ver se é 100%.



203. Set


Set<T>
	• Representa um conjunto de elementos (similar ao da Álgebra)
	• Não admite repetições
	• Elementos não possuem posição
	• Acesso, inserção e remoção de elementos são rápidos
	• Oferece operações eficientes de conjunto: interseção, união, diferença.
	• Principais implementações:
	• HashSet - mais rápido (operações O(1) em tabela hash) e não ordenado
	• TreeSet - mais lento (operações O(log(n)) em árvore rubro-negra) e ordenado pelo compareTo do objeto (ou Comparator)
	• LinkedHashSet - velocidade intermediária e elementos na ordem em que são adicionados
	• https://docs.oracle.com/javase/10/docs/api/java/util/Set.html


Alguns métodos importantes
	• add(obj), remove(obj), contains(obj)
	• Baseado em equals e hashCode
	• Se equals e hashCode não existir, é usada comparação de ponteiros
	• clear()
	• size()
	• removeIf(predicate)
	• addAll(other) - união: adiciona no conjunto os elementos do outro conjunto, sem repetição
	• retainAll(other) - interseção: remove do conjunto os elementos não contitos em other
	• removeAll(other) - diferença: remove do conjunto os elementos contidos em other


Basicamente é uma insterface para trabalhar com listas, e como já está descrito tem inumeras operações mais rapida ou mais lentas mais ainda assim é bem interresante.


204. Como Set testa igualdade


Aqui ele explica que na real a forma de testar igualdade é igual de outras listas que é via equals e hashCode  porque como ele instancia eles na memoria ele vai ser diferente e é por isso que tem que ter implementado o equals e hashCode.


205. Como TreeSet compara os elementos

Aqui ele diz que quando você está usando o  TreeSet você é obrigado a implementar o compareTo e sua classe ser um implements de Comparable<T>, porque como o TreeSet faz a inserção dentro da lista de forma ordenada eu sou obrigado a usar o equals e hashCode mais o compareTo e ai eu informo o que ele vai comparar.


206. Exercício resolvido (Set)

Aqui ele mostra como deve ser a utilização do set e ainda mostra melhor que o set sempre vai impedir a duplicidade de itens dentro de uma coleção(ou lista).


208. Map


É uma coleção de pares chave / valor
	• Não admite repetições do objeto chave
	• Os elementos são indexados pelo objeto chave (não possuem posição)
	• Acesso, inserção e remoção de elementos são rápidos
	• Uso comum: cookies, local storage, qualquer modelo chave-valor
	• Principais implementações:
	• HashMap - mais rápido (operações O(1) em tabela hash) e não ordenado
	• TreeMap - mais lento (operações O(log(n)) em árvore rubro-negra) e ordenado pelo

compareTo do objeto (ou Comparator)
	• LinkedHashMap - velocidade intermediária e elementos na ordem em que são adicionados


Alguns métodos importantes
	• put(key, value), remove(key), containsKey(key), get(key)
	• Baseado em equals e hashCode
	• Se equals e hashCode não existir, é usada comparação de ponteiros
	• clear()
	• size()
	• keySet() - retorna um Set<K>
	• values() - retornaa um Collection<V>

Aqui eu sou obrigado e informar uma chave e um tipo para o valor, e sempre que eu for comparar um elemento com o outro eu tenho que usar o equals and hashcode, porque se não ele vai usar a referencia de ponteiro o que nunca vai ser igual a menos que você faça alguma gambiarra para isso acontecer.

209. Exercício de fixação (Map)

Tive que pegar o dele mais sem problemas.


Seção 20: Programação funcional e expressões lambda

210. Visão geral do capítulo Programação Funcional e Expressões Lambda

211. Material de apoio do capítulo

212. Uma experiência com Comparator

Aqui ele da uma iniciada no lambda e mostra as diferentes formas de se usar lambda no JAVA, é claro que só em uma pincelada não se aprende tudo mais deixa o código menor e mais bonitinho, claro que pode chegar em um ponto que ninguém mais intender.

obs. baixei os exemplos dele e deixei no repositório.


213. Programação funcional e cálculo lambda

expressão lambda são funções anonimas de priomeira ordem, ou seja elas não são declaradas mais podem ser passadas como argumentos para outras funções, e que suas variaveis não precisam ser declaradas para serem utilizadas.



214. Interface funcional

Expressões lambda no fundo são interfaces funcionais, e uma interface funcional é uma interface que possui apenas um método abstrato.


215. Predicate

Aqui ele explicou melhor como funciona a parada do predicado, e as formas de se utilizar, acho que a mais simples de todas é passar direto uma expressão lambda do que ficar declarando uma caralhada de coisa e classes que talvez tu nunca vá utilizar, mais ainda assim algumas delas dependendo do problema da para ser utilizada sem problemas.


216. Consumer

Aqui ele mostrou a mesma declaração e utilização da interface do predicate na interface consumer, é a interface consumer ela só executa uma ação, e não tem devolução nenhuma.


217. Function

Aqui ele mostrou que essa interface function ela recebe alguma coisa e tranforma em alguma outra coisa, no caso ele recebeu uma lista do tipo product e devolveu uma lista do tipo string, esse cara você é obrigado a passar o tipo que vai entrar e o tipo que vai sair, esse aqui já é mais ousado e deve ter muito mais utilização.


218. Criando funções que recebem funções como parâmetro

Aqui ele mostrou como podemos criar as nossas classes para receber uma função como argumento, e na real ele preparou a classe para receber um predicado como parâmetro de chamada o que faz com que eu não precise mais alterar a classe que vai receber os parâmetros caso mude alguma regra.


219. Stream

Aqui ele mostrou como fazer ou usar a stream, e basicamente a stream é uma sequencia de elementos que podem vir de qualquer lugar e que seram transformados em alguma outra coisa, ou em lista, ou coleção.


Operações intermediárias
• filter
• map
• flatmap
• peek
• distinct
• sorted
• skip
• limit (*)
* short-circuit


Operações terminais
• forEach
• forEachOrdered
• toArray
• reduce
• collect
• min
• max
• count
• anyMatch (*)
• allMatch (*)
• noneMatch (*)
• findFirst (*)
• findAny (*)
* short-circuit


Criar uma stream
• Basta chamar o método stream() ou parallelStream() a partir
de qualquer objeto Collection.
https://docs.oracle.com/javase/10/docs/api/java/util/Collection.html
• Outras formas de se criar uma stream incluem:
• Stream.of
• Stream.ofNullable
• Stream.iterate

Bem o assunto é muito extenso porém muito importante que se tenha uma compreensão muito vasta e ampla para que seja ainda mais facilitado a codificação e a forma como resolvemos problemas.


220. Pipeline (demo)

Aqui ele na real so mostrou mais algumas operações nada de muito complexo nem muito aprofundado.


221. Exercício resolvido (stream)

Resolveu um problema usando apenas lambda, é facil mais é muito verboso, sempre que se tem que fazer alguma coisa no java é verbo atrás de verbo, se é loko.


222. Exercício de fixação

copiei mesmo na alta o exercicio do dele, acho que a falta dessa pratica pode me fazer falta algum dia, mais por enquanto eu só quero terminar logo essa porra.


Seção 21: Acesso a banco de dados com JDBC

223. Visão geral do capítulo

224. Material de apoio do capítulo

225. Visão geral do JDBC

Aqui ele explica que na real quando usamos o JDBC que é a biblioteca padrão do java para acesso a base de dados escrevemos código java e ai instalamos na nossa aplicação o drive do JDBC que converte nosso código java para a linguagem nativa do banco de dados , independente de qual seja.

226. Nivelamento: Álgebra Relacional e SQL

Aqui ele fala apenas de SQL, como o nome da aula já diz "nivelamento".


227. Instalando o MySQL

Aqui ele mostra como instalar o MySQL no Windows, nada de anormal, pelo contrario tão padrão que da até nojo. rs


228. Preparação do primeiro projeto no Eclipse - PARTE 1

Aqui ele mostrou que temos que baixar o drive do mysql para poder utilizar no nosso projeto e que ainda temos que adicionalo ao eclipse manualmente para poder utilziar, ai iniciamos criando um arquivo de coneção com o banco e já começamos a criar uma classe personalizada de erro e uma classe que vai abrir e fechar a coneção porem essa classe ainda não foi implementada.


229. Preparação do primeiro projeto no Eclipse - PARTE 2

Aqui finalizamos a implementação da classe de coneção com banco de dados, foi simples mais como dito anteriormente o java é muito verboso, chato para um caraleo, mais deu tudo certo.

OBS.Ele inseriu uma caralhada de videos novos de correção de exercicio por isso os numeros da aula estão bugados, depois eu arrumo saporra.

234. Demo - recuperar dados


Aqui ele mostrou de uma forma bem simples como recuperar dados de uma tabale com java, o problema é que é muito verboso, e você precisa saber muita coisa para conseguir trazer os dados, claro toda linguagem precisa de muita coisa mais no java é um pouco mais escrito.

mais em fim , tem um arquivo de configuração de conexão com banco de dados que precisa existir, (igual qualquer linguagem), ai você precisa abrir a conexão, fazer preparar a sua consulta usando o "Statement" (classe nativa do JAVA) , e ai você executa, (meio que PDO a parada).
e ai depois você vem fechando tudo que você abriu.


235. Demo - inserir dados

Aqui ele mostra como que temos que preparar os dados para poder inserir no banco de dados, é simples e muito parecido com qualquer outra lingaguem.

e já da para recuperar os id's que foram inseridos no banco de dados, o que facilita 100% a vida do pião.


236. Demo - atualizar dados

Basicamente o que ele fez de diferente do de inserir os dados no banco de dados foi que quando ele preparou a query ele usou os comando SQL de update, só isso.


237. Demo - atualizar dados

**OBS . Os numeros das aulas estão todos errados novamente porque ele inseriu mais aulas.


Basicamente ele cria toda a query na mão em uma variavel que tenha a conexão e passa os valores, ai depois ele exeuta e pronto, igual ao inserte porém o que muda é o comando sql dentro da query.


238. Demo - deletar dados


Mesma coisa, só o que muda é a query, e ainda ele criou uma classe de erro personalizada, não mostra o stackTrace mais ainda mostra o erro da maneira correta isso é só para mostra que da para capturar qualquer erro do jdbc e fazer um erro personalizado.

239. Demo - transações

Basicamente ele mostrou como deve ser uma transação no JAVA, é necessario que você primeiro coloque o autoCommit como false, para que ele não commit qualquer operação antes de finalizar a sua transação.

setAutoCommit(false);

depois você usa o Statement para monstar sua query e ai ele jogou o result em uma variavel para poder ver o que foi feito.

ai no final de tudo se manda ele commitar com o comando.

commit();

ai no método catch você coloca o rollback, porque caso tenha algum erro na execução ele automaticamente vai desfazer tudo que foi feito para não deixar isso ser executado pela metade.

rollback();

e como rollback pode dar erro é necessario um trycathc para o rollback também.

É por isso que o JAVA é tão verboso.


240. Padrão de projeto DAO (Data Access Object)

Aula teorica mais bem ilustrativa de como funciona o tal do DAO, ele basicamente é uma abstração de tudo que eu vou precisar fazer no banco de dados com a minha entidade, ou seja CRUD completo e ainda algumas coisas a mais que forem necessarias.


241. PROJETO - criando projeto e repositório Git

Criamos um novo repositório para aprender tudo quanto a no mundo sobre DAO, e eu adicionei ele como um submodulo dentro da pasta Seção 21, porque nada mais é do que isso ai mesmo, e já fiz o primeiro commit.

242. Classe Department

Criamos a classe Department dentro do novo repo, e já deixamos ela prontinha para qualquer coisa, criamos os contrutores padrão e o com valores, os métodos get e set, adicionamos equals and hashCode para podermos comparar os objetos por conteudo e não só por ponteiros, um toString para poder retornar os valores no console, além de uma parada la de Serializable que ainda não sei para que o que serve mais é um interface.

243. Classe Seller

Criamos a classe Seller com tudo que é necessario igual a department e já testamos e está tudo certo.


244. Interfaces DepartmentDao e SellerDao

Criamos as duas interfaces a do departamente e a do vendedor.


245. SellerDaoJDBC e DaoFactory

Aqui instaciamos o SellerDaoJDBC que na verdade é uma implementação da interface SellerDao e ai fomos obrigados a declarar todos os métodos la, ai na classe DaoFactory que na real é uma "fabrica" de instanciação eu declaro uma instancia do SellerDao e crio um método que vai retornar uma instancia do SellerDaoJDBC que é onde eu tenho todas as operações da minha interface sendo assim eu não preciso mais chamar um (new SellerDao), porque o método que eu to chamando já contem essa instrução, com todos os métodos da inteface já declarados.

JAVA SENDO JAVA


246. Implementando findById

Aqui implementamos o findById é até que relativamente simples, porém como tudo depende de tudo sempre que mexemos em algo precisamos alterar uma caralhada de coisa, mais é até que legalzin, tirando a parte de ser muito verboso.
mais consegui implementar e ainda to conseguindo intender como funciona as paradas com java, e ainda porque é a cabeça de javeiro funciona assim, porque a propria linguagem te obriga a ser assim.


247. Reutilizando a instanciação

Aqui criamos métodos ou funções para reutilizar as instanciações das classes vendedores e departamento.


248. Implementando findByDepartment

Aqui ele basicamente fez um esquema para instanciar uma busca por ID de departamento, só que tem um macete, para não ficar instanciando varias vezes os mesmo objetos, da mesma forma, ele criou um esquema para poder reutilizar o mesmo objeto, primeiro ele valida para ver se não existe um objeto já instanciado com o mesmo id de departamento, se não tiver ele cria se já tiver ele só aponta para esse objeto já instanciado, imagino que isso sirva bem para economia de memoria.


249. Implementando findAll

Aqui não mudou quase nada do método de busca por departamento, só que como eu não tenho que passar nenhum ID de departamento fica um pouco menor o código.s


250. Implementando insert

Aqui é bem tranquilo fazer a implementação do insert, claro que tudo no java é muito verbo, muita escrita mais é relativamente tranquilo, acho que assim que eu mudar o mindSet para o Java já era, vai ficar tudo bem mais facil, mais para isso preciso muito forçar e treinar para aprender.


251. Implementando update

Aqui é igual, depois de monstar o insert basicamente o resto se mantem igual mudando apenas o comando SQL e algumas validações que por ventura voce quiser fazer, na real é até simples depois que faz um.


252. Implementando delete

mesma coisa, mudando o SQL e as validações mais é igual a mesma implementação.


253. Implementação e teste do DepartmentDao

Aqui ele deixou um exercicio para implementarmos o Department com todos os parametros igual ao seller, em execução.

Consegui fazer na copia do seller, não que eu tenha tido muitos probelmas mais ainda falta a aquela pratica e aquele costume com a linguagem.



Seção 22:Interface gráfica com JavaFX

Introdução do modulo


255. Material de apoio do capítulo



256. Visão Geral do JavaFX

Nada de mais, visão geral mesmo


257. Instalação do Scene Builder

baixei o cara mais não preciso instalar, to no linux.


258. Preparação do Eclipse


Acho que consegui , tive que instalar o esquema do JavaFX pelo eclipse marketplace.


259. Criando um novo projeto JavaFX no Eclipse

Consegue fazer a minha primeira telinha, na real é o projeto padrão de uma aplicação, mais tive que fazer um apontamento ainda no projeto para conseguir rodar a parada.

Configuração do build:
o Botão direito no projeto -> Run As -> Run Configurations -> Arguments -> VM Arguments
o Copiar o conteúdo abaixo, adaptando para sua pasta:
--module-path caminho_onde_tu_instalou\java-libs\javafx-sdk\lib --add-modules=javafx.fxml,javafx.controls


260. Testando o FXML


Apanhei igual escravo no tronco para conseguir reconfigurar todo o meu ambiente com as coisa que eu preciso, porque é muita coisinha chata que precisa ser feita, até mesmo importar os pacotes ou libs no eclipse é um parto, além de que ainda tem muita coisa que não funciona ou está com erro.

Fiz uma primeira tela bem boroca usando o sceneBuilder e o JavaFX, mais pelo menos para algumas coisa bem simples isso aqui deve servir.

Obs. Agora com o Ubunto 20.04 consegui configurar tudo corretamente e sem warnnigs, ta tudo funfando como deveria.


261. Tratando eventos com JavaFX

Aqui ele mostrou como funciona as paradas de colocar ações ou interações dos elementos que vão aparecer na tela, isso significa que para cada ação ou interação que o usuario tiver com a tela eu consigo configurar alga ação a ser executada.


262. Mostrando Alert

Aqui basicamente já existe uma classe de alertas padrão, ai ele fez a implementação padrão da classe padrão para podermos brincar.


263. Usando TextField e Label (app para calcular soma)

Aqui ele mostrou que é possivel além de colocar aquelas mensagem (placeholder do html) nos campos, ainda da para você fazer umas paradas maneiras com seu código, é a mesma coisa que trabalhar com html, css e js, tudo vai por ID e primeiro se tem que pegar o id para poder fazer a parada , mais ai aqui tu escreve o que deve acontecer e depois usa o scinebuilder para poder facilitar o desenvolvimento, da até para deixar tudo pronto via codigo e depois só usar o scinebuilder para fazer as "amarrações".


264. Limitações para TextField, interface Initializable

Aqui ele utiliza um classe chamada Initializable  que é padrão do JavaFX e que permite adicionar alguma configurações adicionais antes da instancia da sua classe ou na hora da instancialização, e ai usamos metodos padrão dessa classe para podermos tornar os campos apenas numeros e numeros double e ainda limitamos o tamanho maximo do campo(maxwidth do HTML5).


265. ComboBox

Aqui ele mostra como fazer um campo ComboBox na tela usando o sceneBuilder e as paradas com java, deve ser um saco trabalhar com isso, além, de uma canseira monstra, porém deve ser até que util para quem já conhece e se expecializou nisso ne.


266. Visão geral dos principais containers de layout

Aqui ele apresenta apenas os item de tela mais utilizados por ele e acredito que pela maioria dos dev's de java para criar essas paradas de tela.


Seção 23:Projeto: Aplicação desktop com JavaFX e banco de dados MySQL com JDBC


267. Visão geral do capítulo


268. Material de apoio do capítulo


269. Criação do projeto

Criei o projeto e segui com todas as configurações que ele indicou, mais vamos seguir da seguinte forma, vou copiar apenas os arquivos do diretório que eu la do eclipse para o repositório que está no diretório la do github porque eu adicionei um submodulo, ai vai ser igual o jogo de xadrez, mais vamo que vamo.


270. Criação do projeto

Criei o Projeto no eclipse ,e já tenho o repositório no github.


271. Tela MainView

Aqui apenas adicionamos uma classe que pelo que eu entendi vai ser a classe principal do projeto,sendo assim é isso ai.


272. MainView design


Basicamente já existem itens no prorpio java que conseguem garantir a responsividade dos itens na tela e fazer com que o dev não se mate, mais uma vez é muito berboso , mais vou virar pro nessa porra.


273. MainView controller


Aqui começamos a mapear os campos da tela e ainda a colocar eventos neles, ainda nada muito complexo  apenas mostrando o nome do método chamado quando clicamos em um botão, e o padrão de nomenclatura que ele utiliza é legal, fica extenso que só a porra mais da bom.


274. About view

Basicamente aqui ele fica brincando de redesenhar a tela toda hora, quando ele adiciona um tela nova ele precisa limpar a tela antiga colocar a tela nova junto com os menus que já existiam na tela antiga.


275. DepartmentList view design

Criamos mais uma tela, criar as telas com o sceneBuilder é padrão wix, nada contra facilita e muito tendo em vista que aqui é padrão carroã.


Seção 24: Java EE - Mapeamento objeto-relacional com JPA / Hibernate

300. Visão geral do capítulo
nada de mais

301. Material de apoio do capítulo
baixei

302. Instalação do STS e Postman
level monk

303. Nivelamento JPA / Hibernate - PARTE 1
on this part dont have nothing relevant, just basic things


304. Nivelamento JPA / Hibernate - PARTE 2 (Trabalhando com Maven)
Aqui criamos um projeto maven e adicionamos algumas denpendencias.


305. Nivelamento JPA / Hibernate - PARTE 3
Aqui ele  mostrou como listar os caras no banco, como deletar e explicou que só é possivel remover os caras do banco de dados quando a entidade está "monitorada" que basicamente é quando você ou acaboude inserir no banco de dados ou quando você acabou de recuperar do banco, e aind não pode esquecer de que tem que iniciar a transação e encerrar ela.


Seção 25: Projeto: Web services com Spring Boot e JPA / Hibernate

306. Visão geral do capítulo


307. Material de apoio do capítulo


308. Criação do projeto
Project Created and add how submodule of git on my java course.


309. Entidade User e seu resource
Here we created one class User and one resource call UserResource, and make a test instantiating one User and responsing the object with the WebService or API


310. Banco de dados H2, test profile, JPA
Created database with H2, created profile off test what means created a another "user" to test the application, and insert de resources to run JPA.


311. JPA repository, injeção de dependência,database seeding


312. Camada de serviço, registro de componentes


313. Entidade Pedido. Datas com Instant e padrão ISO 8601 - PARTE 1


314. Entidade Pedido. Datas com Instant e padrão ISO 8601 - PARTE 2


315. Enum OrderStatus


316. Entidade Category


317. Entidade Product


318. Associação muitos-para-muitos com JoinTable


319. Entidade OrderItem. Associação muitos-para-muitos com dados extras - PARTE 1


320. Entidade OrderItem. Associação muitos-para-muitos com dados extras - PARTE 2


321. Associação muitos para muitos entre Product e OrderItem


322. Entidade Payment, associação um para um


323. Métodos subtotal e total


324. Inserção de User


325. Deleção de User


326. Atualização de User


327. Tratamento de exceção - findById


328. Tratamento de exceção - delete


329. Tratamento de exceção - update


330. Criando app Heroku e provisionando banco PostgreSQL


331. Instalação do PostgreSQL


332. Profile dev


333. Obtendo script SQL a partir do PostgreSQL local


334. Executando script SQL no servidor remoto


335. Instalando o Heroku CLI


336. Deploy do sistema no Heroku


337. Testando o sistema em produção
Trocar a versão do JAVA no LINUX

Site com as info
https://tecadmin.net/install-java-on-fedora/

comando: sudo alternatives --config java

 

Curso de JAVA completo Udemy


Curso ministrado na udemy pelo professor nelio alves.


Seção 1: Introdução

1. Introdução: visão geral do curso

Está apresentando o curso e as principais qualidades que ele julga necessárias para ser um bom dev de JAVA, ainda deixou um arquivo que vai ser utilizado no curso.


Seção 2: Conceitos de programação

2. Visão geral do capítulo

3. Material de apoio do capítulo

Baixei o material de apoio

4. Algoritmo, Automação, Programa de Computador

Algoritmo = Sequencia bem definida de passos a serem seguidas
Automação = processo que pode ser automatizado via uma maquina
Programa = é um Algoritmo executado pelo Computador


5. O que é preciso para se fazer um programa de computador

IDE = uma interface de Desenvolvimento
Compilador = transforma o código java em programa de computador


6. Linguagem de programação, léxica, sintática

léxica = a forma de escrever

sintática = é um erro gramatical

programação = é a junção de todas elas mais em uma linguagem de programação.


7. IDE - Ambiente Integrado de Desenvolvimento

Aqui ele está mostrando algumas IDE's e para que serve.


Seção 3: Introdução à linguagem Java

8. Visão geral do capítulo

9. Material de apoio do capítulo


10. Entendendo as versões do Java

LTS - long time support

ou seja longo suporte pela oracle.


11. Histórico e edições de Java

JAVA é uma linguagem de programação mais também é uma plataforma de Desenvolvimento e execução, ou seja tem que instalar os JDKS e todo o ambiente de desenvolvimento.

O java surgiu para resolver o problema de alocação de memoria e o suporte a vários dispositivos com o mesmo código e a mesma aplicação.

JAVA ME  - micro edition = usada para IOT por ser mais leve 

JAVA SE  - Standard Edition = usado para tudo , tem o core do java

JAVA EE  - Enterprise Edition = Aplicações corporativas



12. JDK / JVM - Máquina Virtual do Java

JVM - JAVA VIRTUAL MACHINE

essa aqui é a maquina virtual do java que interpreta e compila o código.

aqui ele mostra que o java é uma linguagem que está no meio termo entre as compiladas e as interpretadas, segundo ele o java interpreta o código e já corrige erros na syntax e na semântica e ai gera o byte code, que ja é otimizado, ai sim ele compila o código já performado , na JVM de cada SO e ai roda lindo.


13. Estrutura de uma aplicação Java

Todo código java tem que estar em classes, e essas classes agrupadas são os pacotes(packages), e vários pacotes agrupados foram um modulo, que por sua vez com vários outros módulos agrupados formam um sistema.
Run-time = é a compilação ou build de um determinado grupo de pacotes para serem instalados em algum dispositivo.


14. Instalando Java

Essas aulas eram no Windows, que é nível macaco e eu já adotei como ambiente de desenvolvimento o LINUX

15. Instalando o Eclipse

Igual a aula anterior


16. Primeiro programa em Java no Eclipse

Aqui ele fala do "workspace" que é o diretório que seus projetos serão salvos, e todas as vezes que o eclipse for inicializado ele vai te perguntar se você quer mudar esse diretório.

outra coisa é a perspetiva, no nosso caso estamos utilizando a JAVA, é só ir em "window > perspective > open perspective > java" caso não tenha vai em "other..." e escolhe o java.

para voltar a perspetiva igual ao padrão vai no mesmo caminho e clica em "reset perspective"

Mostra o console "Window > show view > console"


***
Aqui tem um bizu 

Usando o comando 'sudo alternatives --config java' eu consigo escolher no meu fedora entre quais opções do java eu quero usar, das que estão instaladas no PC.


***

criou o primeiro programa em java, mostrou que sou obrigado a criar uma classe para executar qualquer coisa no java e ainda deixou a classe como sendo executável.

Seção 4: Estrutura sequencial


17. Visão geral do capítulo

18. Material de apoio do capítulo


19. Expressões aritméticas
Aqui ele mostrou os 5 tipos de operadores aritméticos, e mostrou que mesmo em java temos precedência de execução, como na matemática normal, isso significa que tudo que estiver entre parênteses"()" vai ser executado primeiro.
obs. em programação não existe chaves nem colchetes para expressões aritméticas só os parênteses.


20. Variáveis e tipos básicos em Java

Demonstrou como devem ser declarados os tipos de variável no java, explicou como são armazenadas na memoria e que toda variável tem um nome ou identificador, e que possui um tipo (existem vários ele mostrou apenas os 8 primitivos).

Numéricos Inteiros
byte   - 8 bites
short  - 16 bites
int    - 32 bites
long   - 64 bites

Numéricos com Ponto flutuante
float   - 32 bites
double  - 64 bites

Carácter Unicode
char - 16 bites

Valor Verdade
boolean - 1 bite

String
Armazena uma cadeia de Caracteres.

Padrão de nomenclatura de variável
Nunca inicia com números , sempre com letras ou _
Não pode ter espaçoes em branco entre o nome da variável
Não se usa acentuação nem caracater especial
E usa-se o padrão Camel Case, ou seja a primeira letra de cada palavra tem que ser maiuscula.


21. As três operações básicas de programação

Entrada de dados ou escrita = é quando o usuario insere dados por meio de um teclado ou touch

processamento de dados = é o processo que o computador faz com os dados que foram enviados para ele e depois devovlve alguma informação do que foi processado

Saida de dados ou escrita = é o processo de devolução do computador após o processamento para o usuario por meio de um periferico de saida como o monitor.


22. Saída de dados em Java

Para retornar dados para os usuarios temos algumas formas, 

Essa forma não tem uma quebra de linha no final, se eu colocar mais alguma coisa para aparecer na tela ele simplesmente vai escrever tudo junto.
System.out.print("Olá Mundo");


já aqui tem a quebra de linha no final, ou seja fica esse conteúdo e o proximo já estaria na proxima linha.
System.out.println("Olá Mundo");


para imprimir valores de variaveis temos algumas formas
int x = 32;
double y = 10.35784
System.out.println(x);
System.out.println(y);


mais para você poder formatar os valor do double você pode usar o comando 


int x = 32;
double y = 10.35784
System.out.printf("%.2f%n",y);

Aqui o printf é para formatar o numero, e o "%.2f%" é o indicador de que eu só quero duas casas decimais, e o %n serve para quebra de linha na apresentação dos dados, já o proxima valor após a virgula é a variável que eu quero apresentar formatada.

Aqui ainda tem um esquema na formatação que é para apresentação com "." ou "," por padrão o comando "System.out.printf();" ele pega as configurações do seu computador para usar como padrão por isso aqui ele sempre apresenta com "," e para apresentarmos com "." temos que utilizar uma classe padrão do java que é a "Locale"

import java.util.Locale;
Importa ele no começo do programa.

Locale.setDefault(Locale.US);
Usa ela no começo do programa também porque essas configurações só teram efeito depois da declaração do locale.


Para concatenar mais de um dado de retorno é simples é so mandar o "+" entre os textos e as variaveis assim:
System.out.println("Texto qualquer " + y + " Final do texto qualquer");

já nesse exemplo estou concatenando texto formatado com 2 casas decimais, a unica diferença é que se eu tivesse mais alguma coisa para printar na tela e precisaria de mais alguns "%.N" e ai as variaveis tem que ser colocadas na ordem em que eu defini os %.
System.out.printf("Resultado = %.2f  Metros%n", y);

Aqui temos outro exemplo porém concatenando vários tipos de dados no mesmo retorno, ou seja uma string, um inteiro e um double, e para fazer isso temos algumas marcações no JAVA como por exemplo:

%s = String

%d = Inteiro(int)

%f = Ponto flutuante (double)

%n = Quebra de linha

Obs. Tem que declarar as variaveis no começo do programa.
System.out.println("%s tem %d anos e ganha R$ : %.2f reais %n", nome, idade, renda);


Deixou um exercicio de fixação. 

Obs. Movi todo o repositório do git para dentro do meu workspace do eclipse para que assim eu consiga subir os códigos da aula e dos exercícios de fixação.


23. Processamento de dados em Java, Casting

Aqui ele fala que o processamento de dados em java é igual qualquer outra lingaguem onde você cria uma variável e ai depois você atribui uma expressão a ela, ou um valor direto.

e que o casting é quando você faz a conversão explisita de tipos de dados.

uma boa pratica de programação é sempre declarar os valores igual ao seu tipo, exemplo valores double sempre com o ".0" e se for float sempre mandar com "f" depois do numero,  "5f".


O casting seria no caso de uma perda de dados ou conversão de tipos de dados entre algum processamento, por exemplo estou somando dois inteiros e quero forçar que o retorno seja um double eu coloco "(double)" antes das variaveis na declaração que ai o compilador intende que deve converter aquele valor para double, e até mesmo no caso de perda de valor se você usar o casting ele aceita, no exemplo de conversão de double para inteiro.



24. Entrada de dados em Java - Parte 1

Aqui ele mostra que os dados que são digitados via teclado tem uma classe que já pega os dados, a Scanner, é só dar aquele importe que tudo funciona, para pegar os dados cada tipo tem um método especifico.

declaração do Scanner.

        Scanner sc = new Scanner(System.in);

    String x;
    x = sc.next();

    Inteiro
    int x;
    x = sc.nextInt();

    Double
    double x;
    x = sc.nextDouble();

Aqui tem uma parada, o separador de decimal sempre vai respeitar sua localidade, ou seja BR o separador e "," USA o separador é ".", então se você quiser mudar tem que madar o Locale.

    Locale.setDefault(Locale.US);

    Caracter
    char x;
    x = sc.next().charAt(0);
    Aqui o charAt() vai pegar o caracater que você informar a posição, pode ser o 1 como no exemplo acima mais pode ser qualquer outro.



    Ler varias palavras da mesma linha com tipos diferentes
    string x;
    int y;
    double z;
    x = sc.next();
    y = sc.nextInt();
    z = sc.nextDouble();




25. Entrada de dados em Java - Parte 2

    Scanner sc = new Scanner(System.in);
    String s1, s2, s3;
    s1 = sc.nextLine();
    s2 = sc.nextLine();
    s3 = sc.nextLine();
    System.out.println("DADOS DIGITADOS:");
    System.out.println(s1);
    System.out.println(s2);
    System.out.println(s3);
    sc.close();


Exemplo acima ele vai pegar todo o conteudo até a quebra de linha e por isso se usa o "sc.nextLine();"


Quando você usa um comando de leitura diferente do nextLine() e dá alguma quebra de linha, essa quebra de linha fica "pendente" na entrada padrão.
Se você então fizer um nextLine(), aquela quebra de linha pendente será absorvida pelo nextLine().

Solução:
Faça um nextLine() extra antes de fazer o nextLine() de seu interesse.


    int x;
    String s1, s2, s3;
    x = sc.nextInt();
    s1 = sc.nextLine();
    s2 = sc.nextLine();
    s3 = sc.nextLine();
    System.out.println("DADOS DIGITADOS:");
    System.out.println(x);
    sc.nextLine();
    System.out.println(s1);
    System.out.println(s2);
    System.out.println(s3);


O eclipse deu uma call interessante, ele aqui transformou o meu objeto "sc" do Scanner em uma variável statica ou seja eu não vou altera-la nem ninguém , e ai eu declaro ele na inicialização do programa e ainda já era, fica tudo certo.


26. Funções matemáticas em Java

Aqui ele está mostrando que existe uma classe em java que é responsável por cálculos matemáticos, e que praticamente já está tudo la pronto para uso.

A = Math.sqrt(x);   Variável A recebe a raiz quadrada de x
A = Math.pow(x, y); Variável A recebe o resultado de x elevado a y
A = Math.abs(x);    Variável A recebe o valor absoluto de x

• sqrt – raiz quadrada
• pow – potenciação
• abs – valor absoluto

e que é possível executar funções complexas com java apenas concatenando esses métodos.



27. AVISO: exercícios para iniciantes PARTE 1

Aqui ele está explicando que tem exercícios propostos em uma aula do youtube e tals e que os questionarios respondidos estão em um repo no github, ai é meio que obrigatório para quem é iniciante na parada e opcional para quem já desenrola na logica de programação.

vou fazer FODA-SE.

28. Exercícios para Iniciantes - PARTE 1

Baixie o conteudo, vou ver o video e mandar os exercícios.


Video do youtube tem um exercicio. [ done ]

Execicos do PDF

acho que vou mandar uma classe por aula, mesmo que fique bastante conteúdo é melhor mais organizado e bem mais facil a consulta depois.


Seção 5: Estrutura condicional

29. Visão geral do capítulo
Deu uma Introdução bem simplista.

30. Material de apoio do capítulo
Download do material do modulo.

31. Expressões comparativas

Aqui ele está mostrando os operadores comparativos igual o da maioria das linguagens
Operador Significado
>        maior
<        menor
>=        maior ou igual
<=        menor ou igual
==        igual
!=        diferente



32. Expressões lógicas

Operador Significado
&&       E
||       OU
!        NÃO


Aqui é o mesmo esquema da logica matematica, e que também tem em toda linguagem de programação, ele nos exemplos não está usando nada de programação só tabela verdade.

na real aqui ele falo o b asico da tabela verdade, é bem basico mesmo.

33. Estrutura condicional (if-else)

Estrutura condicional é uma estrutura de controle, que depende de uma condição, o que significa que se eu quiser tomar uma determinada ação eu devo verificar se aquela condição foi atendida ai sim eu executo o que foi programado.


existe três tipos de estrutura condicional a simples, composta e aninhada ou encadeadas.

Aqui tem umas dicas, se você tem apenas uma condição no seu if não precisa colocar as chaves, é opcional, mais mesmo assim é o esquema colocar para não se perder no código.

não tem condição no else, e da para mandar o else if mais ou menos igual no php , ai se usa dessa forma aqui


if ( condição 1 ) {
    comando 1
    comando 2
}
else if ( condição 2 ) {
    comando 3
    comando 4
}
else if ( condição 3 ) {
    comando 5
    comando 6
}
else {
    comando 7
    comando 8
}


34. AVISO: exercícios para iniciantes
Aviso e mais nada, mesmo assim vou fazer os exercícios e dane-se.


35. Exercícios para Iniciantes - PARTE 2
Termieni os exercícios.


36. Sintaxe opcional - operadores de atribuição cumulativa
Aqui ele mostra que fazer do jeito que ele costuma fazer da certo mais é melhor fazer utilizando os operadores de atribuição acumulativa.


a += b;     a = a + b;
a -= b;     a = a - b;
a *= b;     a = a * b;
a /= b;     a = a / b;
a %= b;     a = a % b;


37. Sintaxe opcional - switch-case

Aqui ele mostrou a syntax do switch-case, que nada mais é que uma alternativa para você não ter que ficar fazendo inúmeros if else, claro que não é só isso, ele tem inúmeras vantagens, e ainda deixa o código mais legível.

padrão igual a maioria das linguagens abre o "switch(){}" com uma expressão ou variável como parâmetro, e ai vem as condições dentro das chaves todas elas com seus "case" a syntax é essa.

switch ( expressão ) {
    case valor1:
        comando1
        comando2
        break;
    case valor2:
        comando3
        comando4
        break;
    default:
        comando5
        comando6
        break;
}

Caso exista e você quiser colocar quando você usa o "default" se nenhum dos valores do case existirem ele apresenta essa mensagem.



38. Expressão condicional ternária

Aqui ele mostra a syntax da condicional ternário que serve para simplificar código if else, e claro se você não tiver muitas condições para serem verificadas.

syntax:
( condição ) ? valor_se_verdadeiro : valor_se_falso

( 2 > 4 ) ? 50 : 80 = Aqui o resultado vai ser 80 porque o resultado da expressão é negativo, então ele vai para o 80
( 10 != 3 ) ? "Maria" : "Alex" = Aqui o resultado é maria porque o resultado da expressão é verdadeiro

Aqui é claro vai depender muito a utilização, nem todo mundo conhece a ternário, e mesmo assim é para coisas bem simples, mais ainda assim acho que como sempre o if else é o mais utilizado nem lembramos do ternário.


39. Escopo e inicialização

Aqui ele mostra os escopos dentro do programa, e mostra que no java as variaveis para terem sido iniciadas não basta apenas terem sido declaradas, elas tem que possuir algum valor, mesmo que "0". e que também variaveis que foram declaradas dentro de funções não existem no escopo fora da função a menos que você declare ela no escopo global não adianta ela não vai funcionar. 


Seção 6: Estruturas repetitivas
40. Visão geral do capítulo

falou como que vai funcionar o modulo.

41. Material de apoio do capítulo
baixei o material de apoio.

42. Como utilizar o DEBUG no Eclipse(execução passo a passo)

Mostrou utilizar o DEBUG no eclipse , é bem simples ao invés de executar com java aplication usa o "debug as " e ai sim o java aplication, ele vai mudar a perspectiva para o modo debug caso voce aperte sim para  a mensagem que aparecer.
para passa linha a linha é só usar o "F6" e ai ele vai passando linha a linha a execução do programa.


43. Estrutura repetitiva enquanto (while)

Aqui ele mostrou como funcina o while, e que ele é utilizando para repetir uma ação ou executar algo enquanto uma condição for verdadeira, e que ele é mais utilizado para quando não se sabe ao certo a quantidade de vezes que será necessario executar.

syntax
while ( condição ) {
    comando 1
    comando 2
}


44. Teste de mesa com estrutura repetitiva enquanto

ele executou um teste de mesa com while, e fez executando linha a linha para conseguirmos enteder como funciona a execução do programa e como se da composição de valores em uma estrutura como o while.

45. Exercícios de teste de mesa com while

Disse que tem exercícios no PDF como teste de mesa, eu fiz todos , é bem maneiro,porque você acaba percebendo como que ele vai ser executado e talvez consiga perver algum erro.


46. AVISO: exercícios para iniciantes PARTE 3
Aviso para fazer o exercicio quem é iniciante, ou tem dificuldade de entender.

47. Exercícios para Iniciantes - PARTE 3
exercícios feitos.



48. Estrutura repetitiva para (for)

O for serve para quando você já sabe previamente a quantidade de vezes em que você vai precisar executar uma ação, tem que praticar porque é um pouco diferente a forma de usar para pegar os valores digitados pelo usuario, eu sempre usei o for para retorno de BD.


49. Teste de mesa com estrutura repetitiva para

Acompanhei ele fazendo o teste de mesa.


50. Exercícios de testes de mesa com for

Falou que vai ter exercícios.

51. AVISO: exercícios para iniciantes PARTE 4

vou fazer do mesmo jeito, são exercícios de teste de mesa que estão no material de apoio, to acertando suave.
fiz todos, acho agora que fazer essas paradas não são perca de tempo, acredito que além de fixação serve muito para fazer sua cabeça pensar em como tudo isso funciona e como deve funcionar.


52. Exercícios para iniciantes PARTE 4

Fiz todos os exercícios.


53. Estrutura repetitiva faça-enquanto (do-while)

Aqui é bem interessante porque ele executa o bloco de instrução antes de fazer a validação, o que é util quando você sabe que precisa pelo menos uma unica vez executar todo o seu bloco.


Seção 7: Outros tópicos básicos sobre Java
54. Material de apoio do capítulo
Baixei o material

55. Restrições e convenções para nomes

Aqui nada mais é que o padrão de nomenclatura 

Camel case: lastName
    pacotes
    atributos
    métodos
    variaveis e parâmetros


Pascal Case: ProductService
    classes


56. Operadores bitwise

Aqui ele está falando que essas operações bitwise são operações bit a bit, e que se eu passar dois valores binarios por exemplo para serem comparados ele vai comparar usando a tabela verdade bit a bit dos dois números binarios que eu passei.

tem as operações logicas normais.


usa normal 
var_1 & var_2; E
var_1 | var_2; OU
var_1 & var_2; OU-exclusivo


57. Funções interessantes para String

Aqui as paradas para formatação de string ou para trabalhar com string são bem pareceidas com o PHP, mais ainda assim em algumas diferenças, mais assim como o PHP eu tenho que dar uma olhada ainda melhor nos DOCS, deve ter muito mais coisa para string.


58. Comentários em Java (básico) 

Comentário de bloco é quando eu abro com "/*" e no final do bloco independente de em qual linha eu fechei o "*/" esse é o bloco de Comentário.

o Comentário de linha é só mandar um "//" e ai ele comenta tudo naquela linha


59. Funções (sintaxe)

Explicou como funciona uma função em java,e explicou o que é uma função, vantagens e desvantagens.


Seção 8: Introdução à Programação Orientada a Objetos
60. Visão geral do capítulo

61. Material de apoio do capítulo


62. Resolvendo um problema sem orientação a objetos

Aqui ele meteu marcha e fez logo um programa que calcula a area de 2 triangulos e ainda vê qual deles tem a area maior, ele fez no procedural mesmo, e na proxima aula vai mandar no Orientado a Objetos.

E ele também está mudando a estrutura de pastas, agora ele está colocando o "String Args" no package aplication.


63. Criando uma classe com três atributos para representar melhor o triângulo

Aqui ele explica melhor o que é uma classe, e que ela tem atributos e métodos e que os atributos são as caracteristicas da classe, e que os métodos são funções que essa classe executa, e recebe o nome de método porque só faz parte da classe e não do escopo todo do programa.

falou sobreos pricipios de uma classe, mais bem preve, e mostrou que todas as vezes que você instancia uma classe na real na "STACK" o valor que fica armazenado na varivel do tipo "Object" é uma referencia de memoria que aponta(ponteiro) para a area da "HEAP" onde realmente está os valores armazenados para cada atributo daquele objeto, e que os objetos por serem assim precisam ser instanciados, e isso é feito com o comando "new" e isso que diz ao programa para armazenar aquela referencia de memoria onde ele vai armazenar os valores.



64. Criando um método para obtermos os benefícios de reaproveitamento e delegação

Aqui ele passou todo a função que calcula  area do triangulo para dentro da classe tornando assim um método, e ainda simplificou poruque ele criou o método uma vez e utilizou para dois triangulos diferentes.

muita coisa está comentada nos códigos quando for mais conceitual eu mando aqui, ou vou intercalando, o que for mais importante deixar la eu deixo e o que for conteúdo normal eu mando aqui mesmo.

Falou sobre o projeto de classe em UML, que facilita a visualização do que tem que ser construido e como deve ficar, com seus atributos e métodos , e com seus respectivos tipos de dados.
 
e frizou mais uma vez que com classes você reutiliza código, o que torna o processo mais agil e e menos caro, e que com as classes você consegue delegar responsabilidade, para cada classe ser especializada naquilo que ele faz.



65. Começando a resolver um segundo problema exemplo

Aqui ele fez uma classe de produto que tem 3 métodos e 3 atributos, nada muito complexo mais bem legalzin para ir fixano as paradas na mente.


OBS. acho que vou começar a criar um pacote por aula, ou fazer tudo que tiver que fazer commitar e apagar porque ta foda, o eclipse entra em loop na hora de builda as paradas e ainda fica dando erro porque tem mais de um método inicial.


66. Object e toString

Aqui ele apresenta o "toString();"  esse cara basicamente é nativo do Object em java que é a classe pai de todos os objetos, e aqui ele consegue sobrescrever o método nativo e alterar o comportamento dele, o que não muda a utilização do método mais sim o retorno dele.

ainda apresentou o "String.format(format, args)" que serve para formatar strings basicamente ali ele fala o formato que ele quer que saia e quala variável que vai ser formatada assim.

OBS. ainda falta mudar os valores mais está funcionando certinho até as chamadas dos métodos.

67. Finalizando o programa

Aqui finalizamos o programa colocando as informações formatadas e apenas somando a quantidade de produtos em estoque, achei que eu já tivesse colocado as informações no github mais se pans não o fiz.


68. Exercícios de fixação

Fiz todos os exercícios de fixação , eu só fiquei pistola porque o ultimo exercicio que o cara mandou fazer não tinha exemplo e o melhor ele deu peso para as notas, mais ai no exemplo dele não tem peso nenhuma nas notas, até porque o peso que ele deu valeria de porra nenhuma peso doido da peste.


A Partir daqui eu vou ter que criar um projeto por aula, ou pelo menos qundo for importante, porque o eclipse aqui do linux buga lindo quando eu tenho mais de uma classe com o método de inicialização, e quando tiver mais conteúdo da mesmo aula acho que vou comentar dentro da propria classe o exemplo ai fica mais facil de achar depois.



69. Membros estáticos - Parte 1


Membros estaticos são membros da classe, e eles não precisam de objetos para serem chamados e sim apenas a classe, como por exemplo o "Math.sqrt()", aqui é um exemplo de membro estatico , eu não preciso ter um objeto instanciado para executalos, ou chamalos.


Dica : NÃO É possível CHAMAR métodoS QUE NÃO SEJAM ESTATICOS DENTRO DE UM OUTRO método ESTATICO, POR EXEMPLO CHAMAR UM método QUE NÃO SEJA STATICO DENTRO O PROGRAMA PRINCIPAL, SE ELE PERTENCE A UMA CLASSE E TEM UMA INSTANCIA BELEZA CASO CONTRARIO ESQUECE, métodoS ESTATICOS SÓ PODEM SER CHAMADOS DENTRO DA PROPRIA CLASSE AO QUAL ELES PERTENCEM.


E para declara constantes é bem simples é só mandar um "public static final" e declarar o nome da constante tudo em letras maiusculas.

Aqui eu intendi que na real tudo depende de onde e como você vai utilizar, depende da necessidade de negócio da sua aplicação, porque os dois jeitos funcionam, e ainda tem o terceiro que vai ser apresentado na aula 2.


70. Membros estáticos - Parte 2


Aqui ele deixou tudo como estava basicamente, porque ele voltou tudo para "static" mais ainda assim ele deixou dentro da classe, acho que tudo que tenha uma formula e que essa formula não mude pode ser deixado como "static" claro que as vezes não é tão rapido e pratico assim mais da para fazer.


Aqui basicamente ele criou métodos porém com a diferença de não precisar instanciar nenhum objeto só chama ele com o nome da classe e o nome do método.



71. Exercício de fixação

Aqui na real não intendi muita coisa, só que eu fiz tudo certo e no final das contas não deu certo, acho que o eclipse estava tudo bugado, eu não conseguia executar as paradas direito,acho que ele tava com informação na memoria e conflitava com a que eu queria executar.

além disso eu não intendi o porque dele colocar o valor do IOF que era uma porcentagem para ser multiplicado e ainda somar esse valor com 1.0, mais vamo ai.



Seção 9: Construtores, palavra this,sobrecarga, encapsulamento

72. Visão geral do capítulo


73. Material de apoio do capítulo


74. Construtores

Todas as classes tem um método construtor e ele é executado na hora que instanciamos a classe, quando utilizamos o "new" ele é acionado para fazer a construção/instacição do objeto na memoria.

Basicamente todos os objetos possuem um método construtor padrão,  e ele não espera nada como parâmetro de entrada, porém é possivel previnir possiveis erros na hora da utilização da sua classe, criando um construtor.

assim esse construtor que você criou vai sobrescrever o default e toda vez que alguém for utilizar sua classe(instanciar) ele vai ser obrigado a passar todos os parâmetros que sua classe precisa porque você obriga isso na instanciação.


Nessa aula ele alterou o código de gerenciamento de estoque, fazendo com que na hora da construção eu seja obrigado a passar todos os parâmetros do objeto, porque segundo a lenda não faz sentido eu criar um objeto vazio primeiro para depois passar os valores para dentro dele,só que também não faz sentido criar variaveis temporarias para isso, mais cada louco com suas loucuras.


São os Arquivos que estão no projeto "aula_65".


75. Palavra this

Palavra this serve para diferenciar atributos de variaveis locais, ou seja quando dentro do método eu uso "this.algumaCoisa" eu to falando que esse meu atributo é valor que foi passado para o objeto e não o que está na variavel local do programa, ou seja eu não corro o risco de pegar um valor que já pode ter sido alterado, e vou pegar o valor que foi passado para o objeto.


Também da para usar o "this" para passar um objeto como argumento/parâmetro dentro de uma função.


76. Sobrecarga

Aqui eu vou criar um projeto novo para essa aula usando o que já ta pronto da aula_65 e que foi modificado na aula 74, acho melhor e evita erros no eclipse, até porque isso é como se fosse um repositório meu, um lugar onde eu posso voltar para buscar informações e esclarecimentos.

Aqui basicamente ele mostra que sobrecarga é o processo de disponibilizar mais de uma forma de instancia de uma mesma classe, ou seja eu consigo ter uma mesma classe que obriga o cara a digitar o nome e a idade e também é possivel eu criar um objeto dessa classe passando apenas o nome, poruq eu tenho varios metodos construtores  que possibilitam isso, na pratica é para o caso de eu por exemplo fazer uma operação matemática onde eu não tenha algum dos valores e tenha que descobrir esse valor ai utilizo o construtor que não obriga a passagem dele e fecho.


77. Encapsulamento

Consistem em esconder informaçãoes importantes da aplicação ou até acesso a dados da classe, expondo as apenas por meio de uma operação segura.

O objeto deve sempre estar em um estado consistente e a classe deve garantir isso, fazendo com que qualquer dado que entre na classe entre por um determinado acesso.


ou seja só deve receber dados via get() e set() FODA-SE.


78. Gerando automaticamente construtores, getters e setters com Eclipse

Aqui é bem simples na real vai no eclipse e clica no botão direito vai em " source -> Generate Constructor using Fields " isso para gerar os construtores e ainda você escolhe quais parâmetros você vai colocar no seu construtor.

para gerar os Getters e os Setters vai em " source -> Generate Getters and Setters " e escolhe também quais parâmetros você que seja criado os getters e setters.


79. Modificadores de acesso

private: o membro só pode ser acessado na própria classe

(nada): o membro só pode ser acessado nas classes do mesmo pacote

protected: o membro só pode ser acessado no mesmo pacote, bem como em

subclasses de pacotes diferentes

public: o membro é acessado por todas classes (ao menos que ele resida em um módulo diferente que não exporte o pacote onde ele está)



81. Correção do exercício de fixação - Parte 1

Basicamente eu não tinha percebido que aqui ele já queria que eu usase encapsulamento e que na real a regra era toda em apenas uma classe, acho que preciso mesmo focar em logica de programação.



82. Correção do exercício de fixação - Parte 2

Aqui ele termina a explicação do exercicio, na real é até que bem simples mais tenho que mudar minha cabeça quando se trata de programação, ainda penso estruturado e fico meio perdido na hora de codar uma classe e pensar em como funciona, mais a pratica leva a perfeição e assim começando cedo termina cedo.


Seção 10: Comportamento de memória, arrays, listas
83. Visão geral do capítulo
84. Material de apoio do capítulo

85. Tipos referência vs. tipos valor

Aqui basicamente o que ele disse foi o seguinte, que são do tipo referência todas as classes porque quando eu estancio uma classe ela na realidade recebe um valor de memoria que indica exatamente onde os valores daquele objeto está, ou seja na memoria STACK ele fica com o valor de memoria HEAP onde estão todos os valores daquele objeto.

isso é chamado de alocamento dinamico de memoria.

quando inicio uma variavel com tipo mesmo, na memoria STACK fica o valor propriamente dito, porque ele não precisa de mais espaço ele é o que é.

e toda variavel de tipo valor tem que ter sido inicializada com um valor, porque se não a propria IDE já avisa que vai dar erro.


Tipos referência vs. tipos valor
CLASSE 
Vantagem: usufrui de todos recursos OO

Variáveis são ponteiros

Objetos precisam ser instanciados usando new, ou apontar para um objeto já existente.

Aceita valor null

Y = X;
"Y passa a apontar para onde X aponta"

Objetos instanciados no heap

Objetos não utilizados são desalocados em um

momento próximo pelo garbage collector

TIPO PRIMITIVO

Vantagem: é mais simples e mais performático

Variáveis são caixas

Não instancia. Uma vez declarados, estão prontos para uso.

Não aceita valor null

Y = X;
"Y recebe uma cópia de X"

"Objetos" instanciados no stack

"Objetos" são desalocados imediatamente quando

seu escopo de execução é finalizado 


86. Desalocação de memória - garbage collector e escopo local

garbage collector é um assistem de desalocação dinamica de memória, o que ele faz basicamente ele fica meio que escaneando o código para tentar encontrar variaveis que foram instanciadas e perderam a referencia, ou seja estão na memoria STACK porém apontam para o mesmo lugar na memória HEAP


Desalocação por escopo é quando eu tenho um escopo de execução seja uma função  ou um if, quando eu declarar variaveis dentro do escopo dessa função ou desse if a variavel só existe ali, e após a execução desse cara essa variavel é desalocada , mais não pelo garbage collector e sim porque o escopo onde aquela variavel foi declarada terminou sua execução.

OBS. garbage collector só existe para limpar objetos que não estão mais em uso da memória, porque variaveis normais com escopo local são removidas da memória imediatamente após o termino do escopo.



87. Vetores - Parte 1

Basicamente é chamado de vetor porque ele tem apenas valores na vertical, e em inglês fica array porque o nome do vetor seria arranjo de valores, dai o array.

esse cara quando você cria ele e passa a quantidade de valores que ele vai ter dentro dele ela automaticamente já cria na memoria espaço para a quantidade de valores que você colocar.

obs. padrão array começa com 0.

vantagens é que se eu tentar acessar qualquer posição dele eu consigo facilmente.

desvantagens é que se eu precisar remover um valor do meu array eu sou obrigado a jogar todos os outros valores para cima o que da muito trabalho , isso claro falando de valores no meio do array , se for o 1 item do array ou o ultimo é mais facil.

Felizmente não tem muito como correr para percorre um vetor segue ainda aquele padrão for.



88. Vetores - Parte 2

Aqui ele mostrou como se cria um array de objetos, basicamente como a maioria das coisas no java é referencia e memoria, o array de objetos também é, aqui você primeiro cria um array passa para elea quantidade de itens que ele vai ter e quando for para atribuir os valores para dentro do array você passa uma instancia de um objeto, ai ele vai armazenar naquela possição a referencia de memoria daquele objeto que foi instanciado.

É meio complicado e meio dificil de intender mais ao mesmo tempo faz um sentido pela arquitetura da linguagem, como ela sempre tem a parada de referenciar objetos com suas posições na memoria nos vetores não foi diferente, acho que fica meio complicado fazer assim mais vamos que vamo.


89. Exercício de fixação

Já fiz o exercicio e commitei no repositório.


90. Boxing, unboxing e wrapper classes

Boxing é o processo de criar um objeto apartir de uma variavel de tipo primitivo, ou seja eu tenho uma variavel int e com ela eu crio uma um novo objeto que recebe o valor dela.

unboxing é quando eu crio uma variavel de tipo primitivo apartir de um objeto no caso eu preciso fazer o casting para o tipo equivalente do dado para dar certo.

wrapper classes são classes padrão do java que servem para que eu consiga tornar todas as minhas variaveis de tipos primitivos em objeto para que não de erro quando eu for fazer o meu programa.

basicamente esses caras aqui são utilizados para fazer com que eu consiga converter variaveis de tipos primitivos em objetos e que eu consiga armazenas valores nullos nelas, porque as variaveis de tipos primitivos padrão não aceitam nulo.

OBS. toda variavel de tipos primitivo tem uma wrapper class correspondente, para que seja possivel utilizar esses caras sem fazer canting .


91. Laço for each

O for each é uma estrutura de repetição que executa enquanto tiver intens dentro de uma coleção(array), e ele tem quase a mesma syntax do for normal.

for(tipo apelido : coleção){

}

é um pouco mais simples do que o for mais não sei qual as vantagens de usar ele.

92. Listas - Parte 1

Listas são estruturas de dados homogeneos ou seja sempre os valores são do mesmo tipo, e todas as listas iniciam vazias e eu posso ir alocando novos itens conforme necessidade, e tem mais cada item da lista conhece tem uma referencia para o proximo nodo(no), e os itens da lista são ordenados e acessados igual array.

toda lista é do tipo 'List' e esses caras são Interfaces

(Interface são classes que definem um padrão de campos e do que vai ser utilizado o B.O é que tem que ser instanciado apartir de uma classe.)

Vantagens de usar List
    tamanho flexivel
    facilidade para se realizar inserções e deleções
Desvantagens
    Acesso sequencial aos elementos

essa parada de acesso sequencial é o seguinte se eu quiser pegar o item 3 da minha lista eu preciso percorrer ela toda , passando por todos os elementos até chegar na posição que eu quero, isso ai da muita merda, mais tem alguns tipos de busca otimizada nas listas por exemplo o ArrayList, que é uma mistura de array com lista que permite percorrer a lista como se fosse um array.

Aqui como o tipo List é uma interface eu preciso de uma classe que implemente essa interface porque eu não consigo instanciar uma interface(acho que em nenhuma linguagem da para fazer isso)


93. Listas - Parte 2

Tamanho da lista: size()

Obter o elemento de uma posição: get(position)

Inserir elemento na lista: add(obj), add(int, obj)

Remover elementos da lista: remove(obj), remove(int), removeIf(Predicate)

Encontrar posição de elemento: indexOf(obj), lastIndexOf(obj)

Filtrar lista com base em predicado:List<Integer> result = list.stream().filter(x -> x > 4).collect(Collectors.toList());

Encontrar primeira ocorrência com base em predicado:Integer result = list.stream().filter(x -> x > 4).findFirst().orElse(null);



94. Exercício proposto

Finalizei o exercicio mais tive que pegar o exemplo dele, porque eu ainda não peguei direito como usar array e listas.


95. Matrizes

Aqui basicamente ele fez uma revisão  mostrando o que são matrizes, que na real é um vetor de vetores, um array bidimensional, ou um array com outros arrays dentro, formando quase que uma tabela.


96. Exercício resolvido

Aqui ele resolveu um exercicio onde eu setava valores para uma matriz, onde o usuario passa a quandidade de linhas e colunas da minha matriz, ai eu tenho que atribuir esses valores no array interno e na possição em que foi digitado, é relativamente simples, o problema é que se não treinar e se não correr atrás nunca vai pegar e sempre vai se lascar quando precisar utilizar.

mais uma parada que eu preciso fortemente estudar, sei la começar a resolver exercicios basicos da net mesmo e ver como eu me saio.

Seção 11: Tópicos especiais em Java

98. Material de apoio do capítulo

99. Trabalhando com datas - Date

Aqui o cara apresenta varias formas de como se trabalhar com data no JAVA, tem as paradas normais mais tem classes especificas para isso, que já são proprias para isso e que ainda auxiliam na formatação dos campos data, o b.o é que nego precisa de pelo menos umas 15 classes para conseguir fazer a formatação    


100. Manipulando um Date com Calendar

Basicamente a classe Calendar tem um monte de metodo, para todos os tipos de manipulação de data, ele deu alguns exemplos pegando dia, e minutos para exemplificar que é possivel, mais eu achei meio imbassado que na real eu sempre preciso setar uma variavel com do Calendar, ai eu pego a data que eu setei e ai passo ela para o calendar, ai eu começo a trabalhar e usar as funções do calendar para manipular data, muia volta para pouca coisa na real.



Seção 12: Bônus - nivelamento sobre Git e Github

101. Visão geral do capítulo Git e Github

102. Material de apoio do capítulo


103. O que é Git e Github

Bem padrão explicou o que é cada um deles e explicou o que é o que faz.

104. Instalação do Git no Windows

Padrão


105. Demo - criando um novo projeto

Mostrou o passo a passo de como criar um repositório local e um remoto e como sincronizlos, além do passo a passo de como subir arquivos para seu repositório remoto e todo paranaue envolvido.

106. Arquivo .gitignore

Explicou que serve basicamente para não versionar arquivos que realmente não precisam ser versionados.


107. Demo - trabalhando com um projeto existente

Aqui ele mostrou como subir alterações no repositório que já possuem alterações e coisas, ai você precisa baixar tudo o que tem no remoto e ai você corrige / altera e sobe


108. Importante entender - a sequência de commits deve ser respeitada

Aqui ele fala que você precisa sempre trazer tudo que está no seu repositório remoto para o seu local, porque se não vai dar conflito nas linhas do commit, e ai você vai ter que fazer o merge ta porra toda.


109. Kit de primeiros socorros

Aqui ele gerou uma listinha com os comandos mais uteis em caso de problema no repositório, apagar alterações e tals.



Seção 13: Enumerações, composição

110. Visão geral do capítulo Enumerações e Composição

111. Material de apoio do capítulo


112. Enumerações

Tipos enumerados são basicamente utilizados para armazenar estados, e para representar com UML só coloca uma anotação emcima do nome da classe informando que é um enum e passa os nomes que você vai aceitar, e na sequencia passa os valores corresponentes aos seus estados.


113. Vamos falar um pouco sobre design

Aqui ele apresenta os tipos de classe que existem no java e que na real por enquanto vamos utilziar as entities mesmo porque era o que estavamos utilizando até agora mais tem muitas, tem todo o esquema do MVC .


114. Composição

Aqui ele da uma introdução teorica sobre composição, e fala que classes que tem dependencia ou que juntas compoem um sistema tem o nome de composição, por exemplo a composição de um objeto pedido eu tenho um objeto cliente +/- isso.


115. Exercício resolvido 1 - Parte 1

Aqui ele começa a apresentar os conceitos de composição quando uma classe tem associação com outra, e ai como funciona ele vai criando varias classes separadas cada uma com sua reponsabilidade, e com seus respectivos dados, sempre permitem ou não acesso aos dados.

tem 4 classes mais a principal que vai usar tudo isso e apresentar para o usuario,é um meio complicado no começo mais quando começa eu começo a pensar nos conceitos de O.O ai vai ficando mais facil de intender o que e como é para ser feito..


116. Exercício resolvido 1 - Parte 2

Aqui ele conclui o programa, e mostra como é bem simples fazer a associação de classes , claro primeiro precisa ficar bem claro na sua cabeça a ordem como tudo vai funcionar se não você vai se perder nas associações, por isso acho que é bem importante ter um modelo visual de como tudo vai funcionar e se relacionar(associar).

acho que quanto mais eu praticar e estudar melhor eu vou ficar.

funciona o programa,acho que eu consigo mandar isso em qualquer lingaguem e em qualquer projeto só focar em como eu devo fazer e aprender a como fazer na ferramenta e na linguagem que eu trabalho.


117. Exercício resolvido 2 (demo StringBuilder)

Aqui ele criou um esquema de Post e comentarios na pegada de blog, foi um exemplo de como usar a composição de classe e ainda mostra a classe stringBuilder, na real essa classe serve para que você não tenho que ficar igual um demente colocando aspas("") e mais (+) na sua system.out.println, a propria classe tem um metodo que se chama "append()", que serve justamente para isso, e ai você consegue ir colocando texto nesses append's e vai criando seu texto.


118. Exercício de fixação


Na real eu até consigo compreender o que ele fez e ir acompanhando mais não da para continuar assim , preciso treinar mais, focar em resolver exercicios,porque acredito que do jeito que o mano faz deve facilitar e muito o desenvolvimento além de que pode ser o jeito mais rapido e prático de se desenvolver programas.


#FOCONOSESTUDOS


Seção 14: Herança e polimorfismo

119. Visão geral do capítulo Herança e Polimorfismo


120. Material de apoio do capítulo


121. Herança

Herança é quando uma classe herda os atributos e metodos de uma outra classe, o que significa que todas as vezes que eu instanciar uma classe que é extenção de uma outra eu não crio duas classes como na composição mais sim apenas uma classe com todos os atributos e metodos das duas classes.

Conceitos em Herança

"é um" -> quer dizer que um carro "é um" automovel, ou seja carro é um automovel assim como caminhão é um automovel, isso é utilizado para pensar em se devemos usar herança ou composição.

Generalização / espeicialização -> quer dizer que a classe pai ou super classe é o tipo mais basico de um objeto e por isso é a Generalização e o que seus filhos são especializados em fazer alguma coisa por isso espeicialização.

Superclasse (classe base) / Subclasse (classe derivada) -> A super classe como dito no conceito acima é a classe pai que dela na teoria vem todos os atributos e metodos que todos devem ter por isso é a super, e ai entra aquele esquema que o eclipse coloca de "super();" esse cara é o que garante que todos as propriedades da classe pai estejam nos filhos, e subclasse é a classe filha que extende de uma outra classe mais generica, e que na teoria deve ser especializada em alguma coisa.

Herança / extensão -> como eu estou literalmente extendendo uma classe com seus metodos e atributos e acrescendo mais coisa nela essa classe filha é uma extensão da classe pai.

Herança é uma associação entre classes e não entre objetos -> como tido em algum lugar acima quando eu instancio uma classe extendida eu não crio dois objetos mais um só isso siginifica que elas são uma parte da outra não da para instanciar um carro sem que ele já venha com as paradas do automovel.

Aqui faltou apenas colocar que quando o uso correto dos modificadores de acesso também impacta na hora da codificação, porque se eu preciso mexer em um atributo de um classe mais esse atribtuto vem da classe pai, ele tem que estar como protected.


122. Upcasting e downcasting

Aqui é bem simples a parada, quando eu to fazendo o Upcasting eu to criando uma instancia de um objeto filho e jogando ele dentro de uma instancia do objeto pai.

ou seja eu tenho uma businessAccount que é um filha de Account, e ai eu crio uma businessAccount mais como tipo dela Account, fazendo com que ele seja literalmente um businessAccount do tipo Account, mais por dentro é uma businessAccount.

e o downcasting é o contrario, eu to criando um objeto do tipo businessAccount e/ou qualquer outro objeto de um tipo filho e tento atribur um objeto pai nele, o que por si só da um erro de compilação, a menos que eu crie o Casting manual informando o tipo daquele objeto para que não de erro.

basicamente essas duas loucuras aqui são para você criar instancias de um determinado tipo mesmo que na verdade o objeto seja de um outro tipo, e pelo que eu vi isso só da para fazer com classes pai e filhas.



123. Sobreposição, palavra super, anotação @Override


Aqui é o seguinte, existe duas paradas, Sobreposição é quando eu implemento um metodo de uma Superclasse em uma subclasse, porém não é possivel alterar os parâmetros nem o retorno mais é possivel mudar o comportamento para que atenda as minhas necessidades.

tem a Sobrecarga que eu consigo mudar tudo, até mesmo os parâmetros.

Aqui tem uma sacada do JAVA que ele utiliza uma anotação para indicar ao compilador que se trata de uma Sobreposição que é o "@Override", eu não sou obrigado a informar essa anotação mais como boa pratica e convenção é fortemente aconselhavel que seja utilizada.

Palavra super, é igual quando eu quero fazer um Upcasting ou Downcasting só que para metodos, eu utilizo o "super.nomeDoMetododaSuperClasse" assim eu consigo utilizar os metodos da Superclasse nas filhas, e até mesmo mudar o comportamento igual o mano fez na aula.

124. Classes e métodos final

Aqui basicamente ele mostrou para que serve a palavra final e que é possivel utilizar ela tanto em classes quanto em metodos.
Basicamente serve para imperdir que uma classe quando ela for final ela não consiga ser herdada por mais ninguém, e o mesmo acontece com quando um metódo tem o "final" no seu nome, ele disse que basicamente isso se aplica quando a regra de negócio necessita, e quando você precisa de uma certa agilidade em tempo de execução porque alguns tipos de dados são executados mais rapidamente quando estão em classes finais.



125. Introdução ao polimorfismo

Aqui ele mostra que o mesmo esquema que já tinha sido feito anteriormente já serve como um exemplo de polimorfismo, porque eu vou ter dois objetos do mesmo tipo chamando metodos com o mesmo nome porém com comportamentos diferentes.

no exemplo da aula não fica igual estou acostumado a ver que é duas instancias da mesma classe com o mesmo tipo chamando os mesmos métodos terem comportamento diferente, mais ainda assim deu mais uma exemplificada.

126. Exercício resolvido

Aqui ele mostra como fazer a parada do polimorfismo de método em um exemplo bem simples, além de ajudar mostrando novamente as paradas das listas, vou ter que estudar ainda mais sobre listas , arrays, Sobreposição e sobrecarga mais isso sempre.


127. Exercício de fixação

Consegui fazer o exercicio praticamente todo, claro que fui seguindo a aula passada mais ainda assim consegui fazer, o que achei meio sacanagem é que ele inicia o contador em "1" para conseguir deixar o contador certo, e que na hora de devolver a data eu tava usando o "getManufactureDate" quando na verdade era usa o proprio atributo "manufactureDate" que dava certo usando o "SimpleDateFormat"


128. Classes abstratas

Classes abstratas são classes do tipo mais generico possivel, elas não podem ser instanciadas porque devem ser genericas ,e só podem ser herdadas e polimorfadas, funcionam mais ou menos como um esqueleto, você consegue utilizar tudo que está la, e consegue usar ela em qualquer lugar desde que não utilize uma instancia dela e sim uma herança.


129. Métodos abstratos

Métodos abstratos são metodos que não possuem implementação, ou seja eles obrigatóriamente devem ser polimorfados, eles sõa utilizados quando a classe é generica de mais para conter sua implementação.

Obs. se a classe tiver um método abstrato obrigatóriamente essa classe vai ser abstrata, e a representação de método e classe abstrata em UML é com nome em italico.


130. Exercício de fixação

Exercicio finalizado com alguns inroscos, mais nada muito complicado tive que dar uma olhada porque eu estava querendo fazer muito mais coisa do que precisava, acho que essa maturidade vem com o tempo.


Seção 15: Tratamento de exceções

131. Visão geral do capítulo Tratamento de Exceções

132. Material de apoio do capítulo

133. Discussão inicial sobre exceções

Uma breve introdução sobre exceções, existe no java uma classe que trata erros e exceções, essa classe tem uma hierarquia de tratamento e varios tipos de exceções, e por ser  uma classe ela pode conter atributos, o ideal é que quem deve tratar as execeções é a propria classe que contém a regra de negócio, mantendo assim aquele principio de responsabilidade clara, e é ideial que sejam tratados os erros ao invés de travar a aplicação.


134. Estrutura try-catch

Aqui ele apresentou a estrutura de try-catch que como eu coloquei direto no código serve mais ou menos como um if-else, porém para tratar erros e execeções, o que eu achei problematico, você precisa conhecer os tipos de erros que sua aplicação pode gerar ou sofrer para poder colocar porque se não ele não funciona, você pode mapear todos os tipos de erros que sua aplicação pode gerar mais ainda assim você vai precisar conhecer os nomes dos métodos de exceção para poder colcar uma ação que seu programa vai tomar quando ela acontecer.


135. Pilha de chamadas de métodos (stack trace)

Essa parada de stack trace, serve para mostrar exatamente onde aconteceu o erro, ele vai mostrando desde onde ocorreu o erro até sua classe "main", no exemplo do aula ele criou dois métodos e um chamava o outro, e dentro deles ocorreu um erro e ele tinha colocado para ser apresentado o stack trace, que nada mais é que aquelas informações de erro que aparecem no console da aplicação, porém quando se usa o try-catch não encerra a aplicação na hora em que ocorre um erro, porque na teoria você tratou aquele erro e mandou seu programa tomar alguma alção quando ele acontecer, porém esse stack trace serve só mesmo para isso para mostrar onde deu o erro igual no console normal do java, mais como vai estar dentro de um try-cathc ele não vai terminar a execução da aplicação.


136. Bloco finally

Esse cara aqui serve basicamente como um "default" do switch-case, porque ele vai ser executado independente de sucesso ou erro na execução da sua aplicação, e como no exemplo eu teria que fechar o arquivo , coloca o bloco "finally" e nele coloca o que for preciso mesmo ser executado.


137. Criando exceções personalizadas

Aqui ele já vai começar a trabalhar com versionamento do GIT, ele vai criar um repositório e colocar todas as versões de tratamento de execeções tanto a muito ruim quando mais indicada, acho que vai ser meio osso ficar escrevendo diretó no código mais ai vou tentar detalhar o melhor possivel aqui mesmo no arquivo de notas.

Reservation.java

Por enquanto ele só fez a classe "Reservation.java" e que tem minhas considerações.
	/*
	 * Aqui é uma parada de uma classe nova, ele mostrou que é possivel calcular
	 * datas atrás de milisegundos e que isso é muito usado no java, aqui ele ta pegando a data que foi digitada 
	 */
	public long duration() {
		long diff = checkOut.getTime() - checkIn.getTime();
		return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
	}



	/*
	 * Aqui basicamente ele fez o simples e colocou um método toString para poder
	 * retornar os dados, mais ainda não tem tratamento nenhum de nada, pelo que eu
	 * vejo.
	 */
	@Override
	public String toString() {
		return "Room " + roomNumber + ", check-in: " + sdf.format(checkIn) + ", check-out: " + sdf.format(checkOut)
				+ ", " + duration() + " nights";
	}


138. Primeira solução - muito ruim

Aqui ele diz que a solução é muito ruim porque toda a logica de negócio e toda solução está no programa principal, que segundo ele é pésimo, eu até concordo mais acho que não teria problemas, o que impacta é que sempre que você precisar mudar alguma regra vai ter que mexer no programa principal.


Program.java


	/*
		 * Aqui toda logica fica no programa principal, o que segundo ele é um problema
		 * e uma pessima solução.
		 * 
		 * 
		 * Aqui a classe "DATE" tem um método que permite ver se a data é antes ou
		 * depois de uma data que informe, por isso que tem o "checkOut.after()" e o
		 * "checkOut.beforer()"
		 */

		if (!checkOut.after(checkIn)) {
			System.out.println("Error in reservation: Check-out date must be after check-in date");
		} else {
			Reservation reservation = new Reservation(number, checkIn, checkOut);
			System.out.println("Reservation: " + reservation);

			System.out.println();
			System.out.println("Enter data to update the reservation:");
			System.out.print("Check-in date (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.print("Check-out date (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());

			/*
			 * Aqui a validação vai nos valores das variaveis mesmo, e na comparação com uma
			 * data que foi setada na mão ali na variavel "now".
			 */
			Date now = new Date();
			if (checkIn.before(now) || checkOut.before(now)) {
				System.out.println("Error in reservation: Reservation dates for update must be future dates");
			} else if (!checkOut.after(checkIn)) {
				System.out.println("Error in reservation: Check-out date must be after check-in date");
			} else {
				reservation.updateDates(checkIn, checkOut);
				System.out.println("Reservation: " + reservation);
			}
		}


139. Segunda solução - ruim

Aqui ele passou quase toda a validação que existia no programa principal para a classe que na real tem que ser responsavel por fazer essas validações, e ai teve que fazer algumas mudanças porque o método que retorna agora retorna uma "String" o que na teoria gera um outro problema, que é a possibilidade de não retornar uma "String" porque deu tudo certo e ai eu fui obrigado a colocar um retorno de método nulo.


Program.java



package application;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;

import model.entities.Reservation;

public class Program {

	public static void main(String[] args) throws ParseException {

		Scanner sc = new Scanner(System.in);
		SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

		System.out.print("Room number: ");
		int number = sc.nextInt();
		System.out.print("Check-in date (dd/MM/yyyy): ");
		Date checkIn = sdf.parse(sc.next());
		System.out.print("Check-out date (dd/MM/yyyy): ");
		Date checkOut = sdf.parse(sc.next());

		if (!checkOut.after(checkIn)) {
			System.out.println("Error in reservation: Check-out date must be after check-in date");
		} else {
			Reservation reservation = new Reservation(number, checkIn, checkOut);
			System.out.println("Reservation: " + reservation);

			System.out.println();
			System.out.println("Enter data to update the reservation:");
			System.out.print("Check-in date (dd/MM/yyyy): ");
			checkIn = sdf.parse(sc.next());
			System.out.print("Check-out date (dd/MM/yyyy): ");
			checkOut = sdf.parse(sc.next());

			/*
			 * Aqui tinha todas as validações mais como essas validações de reserva foram
			 * para a classe certa que é a de validação fica menos pior.
			 */
			String error = reservation.updateDates(checkIn, checkOut);
			if (error != null) {
				System.out.println("Error in reservation: " + error);
			} else {
				System.out.println("Reservation: " + reservation);
			}
		}

		sc.close();
	}
}



Reservation.java


package model.entities;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class Reservation {

	private Integer roomNumber;
	private Date checkIn;
	private Date checkOut;

	private static SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

	public Reservation(Integer roomNumber, Date checkIn, Date checkOut) {
		this.roomNumber = roomNumber;
		this.checkIn = checkIn;
		this.checkOut = checkOut;
	}

	public Integer getRoomNumber() {
		return roomNumber;
	}

	public void setRoomNumber(Integer roomNumber) {
		this.roomNumber = roomNumber;
	}

	public Date getCheckIn() {
		return checkIn;
	}

	public Date getCheckOut() {
		return checkOut;
	}

	public long duration() {
		long diff = checkOut.getTime() - checkIn.getTime();
		return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
	}

	/*
	 * Aqui ele trocou o método para "String" e passou toda lógica que estava antes
	 * no programa principal para cá, ainda ficou coisa la mais já tem mesmo o
	 * principio de responsabilidade clara, que quem tem que ficar com as regras de
	 * reserva é a classe de reserva, o B.O é que na real ainda devolvo uma
	 * "String", o que segundo a lenda é zuado, e como pode ser que eu tenha que
	 * retornar nada porque deu tudo certo ao invés de uma "String" eu preciso
	 * mandar retornar nullo no método.
	 */
	public String updateDates(Date checkIn, Date checkOut) {
		Date now = new Date();
		if (checkIn.before(now) || checkOut.before(now)) {
			return "Reservation dates for update must be future dates";
		}
		if (!checkOut.after(checkIn)) {
			return "Check-out date must be after check-in date";
		}
		this.checkIn = checkIn;
		this.checkOut = checkOut;
		return null;
	}

	@Override
	public String toString() {
		return "Room " + roomNumber + ", check-in: " + sdf.format(checkIn) + ", check-out: " + sdf.format(checkOut)
				+ ", " + duration() + " nights";
	}
}



140. Terceira solução - boa

Aqui ele separou a responsabilidade de cada classe, deixando o programa principal sem nenhuma validação nem regra de negócio e ainda trata todos os tipos de erros, porque ele trata os erros conhecidos e o desconhecido ele manda uma execeção generica.

é a ultima versão do programa que tá na pasta.


141. Exercício de fixação

Terminei a o exercicio como sempre colando o exercicio anterior, mais que desenrolei quase tudo solo, mais vendo o dele é bem interresante também, porque ai fico pouca coisa mais organizado, mais ta legal o meu também.


Seção 16: Projeto: Sistema jogo de xadrez

142. Visão geral do capítulo Sistema Jogo de Xadrez
Carai boracha , parece ser bem loko essa parada, agora eu animei com o javinha.

143. Material de apoio do capítulo

144. Criando projeto e repositório Git

Mano aqui ele sugeriu criar um repositório novo para o jogo de xadrez, acho que vou criar esse novo repositório mais vou deixa-lo como um submodulo, igual ficou o ultimo modulo la dele.


145. Primeira classe - Position

Primeira Aula apenas a criação de uma classe de posição que vai mostra a posição das peças na tela.

146. Começando a implementar Board e Piece

Aqui fez a inserção de mais duas classes para o programa de xadrez, a unica coisa que tem aqui de importante por enquanto é a modelagem que ele fez e utilizou.

147. Camada Chess e imprimindo o tabuleiro

Nessa aula printamos o tabuleiro de xadrez, e criamos a logica de apresentação das pessas, como ainda não tinha peça nenhuma ficou tudo como traço(-), mais as proximas implementações acho que resolvemos isso.

148. Colocando peças no tabuleiro

Aqui já criamos duas peças o rei e a torre, ainda bem simples sem regras sem nada apenas a classe e o retorno dela, o posicionamento ainda é manual mais ja funciona.

OBS. Tive problemas por não copiar corretamente as classes, perdi ai uns 30 min voltando e procurando onde tava o erro.


149. BoardException e programação defensiva

Criamos uma classe de execeção personalizada, e adicionamos validações para evitar que de erro na instanciação, colocar as peças dentro do tabuleiro, não deixar peças sobre peças.


150. ChessException e ChessPosition

Basicamente foi muita coisa, mais ta ficando cada vez mais interessante, porque agora convertemos valores de um tabuleiro em posições de uma matriz e vice versa, além de que temos agora Exceptions personalizadas

151. Pequena melhoria na impressão do tabuleiro

Mudamos aqui para apresentar as peças no tabuleiro com cor diferente,e agora para visualizar essa alteração precisaremos abrir ele no terminal do sistema operacional ou abrir o terminal no eclipse.

OBS. Estou com alguns penos problemas por ainda não ser muito pro nessa parte de SUBMODULO, é a segunda vez que perco informações de um commit, para o outro, tenho que sempre tomar cuidado para não tomar na taraqueta.

152. Movendo peças

Aqui adicionamos os métodos para poder mover as peças, é até que bem simples, primeiro capturamos as posiçoes de xadrez e passamos para um método que vai verificar se existe peça naquela posição de origem, se não houver execeção, se houver remove ela de la, e verifica se tem alguma peça na posição destino, ai remove a posivel peça que estiver la e já coloca a peça removida da origem no destino.


153. Tratando exceções e limpando a tela

Apenas adicionamos um código da net que fica llimpando a tela impedindo que fique com scroll, e adicionamos tratamento de execeções no programa principal.